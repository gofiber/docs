"use strict";(self.webpackChunkfiber_docs=self.webpackChunkfiber_docs||[]).push([["91878"],{28407:function(e,t,n){n.r(t),n.d(t,{frontMatter:()=>o,toc:()=>a,default:()=>h,metadata:()=>r,assets:()=>c,contentTitle:()=>l});var r=JSON.parse('{"id":"middleware/csrf","title":"CSRF","description":"The CSRF middleware protects against Cross-Site Request Forgery attacks by validating tokens on unsafe HTTP methods such as POST, PUT, and DELETE. It responds with 403 Forbidden when validation fails.","source":"@site/versioned_docs/version-v3.x/middleware/csrf.md","sourceDirName":"middleware","slug":"/middleware/csrf","permalink":"/middleware/csrf","draft":false,"unlisted":false,"tags":[],"version":"v3.x","lastUpdatedAt":1771794478000,"frontMatter":{"id":"csrf"},"sidebar":"left_sidebar","previous":{"title":"CORS","permalink":"/middleware/cors"},"next":{"title":"EarlyData","permalink":"/middleware/earlydata"}}'),s=n(74848),i=n(84429);let o={id:"csrf"},l="CSRF",c={},a=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Quick Start",id:"quick-start",level:2},{value:"Best Practices &amp; Production Requirements",id:"best-practices--production-requirements",level:2},{value:"Configuration by Application Type",id:"configuration-by-application-type",level:2},{value:"Server-Side Rendered Apps",id:"server-side-rendered-apps",level:3},{value:"Single Page Applications (SPAs)",id:"single-page-applications-spas",level:3},{value:"Recipes for Common Use Cases",id:"recipes-for-common-use-cases",level:2},{value:"Using CSRF Tokens",id:"using-csrf-tokens",level:2},{value:"Server-Side Forms",id:"server-side-forms",level:3},{value:"Single Page Applications",id:"single-page-applications",level:3},{value:"Security Model",id:"security-model",level:2},{value:"Fetch Metadata Guardrails",id:"fetch-metadata-guardrails",level:3},{value:"1. Token Validation Patterns",id:"1-token-validation-patterns",level:3},{value:"Double Submit Cookie (Default Mode)",id:"double-submit-cookie-default-mode",level:4},{value:"Synchronizer Token (Session-Based Mode)",id:"synchronizer-token-session-based-mode",level:4},{value:"2. Origin &amp; Referer Validation",id:"2-origin--referer-validation",level:3},{value:"Token Extractors",id:"token-extractors",level:2},{value:"CSRF-Specific Extractor Notes",id:"csrf-specific-extractor-notes",level:3},{value:"Route-Specific Configuration",id:"route-specific-configuration",level:3},{value:"Custom CSRF Extractors",id:"custom-csrf-extractors",level:3},{value:"Bearer Token Embedding &amp; Custom Extractors",id:"bearer-token-embedding--custom-extractors",level:4},{value:"Fallback Extraction",id:"fallback-extraction",level:3},{value:"Advanced Configuration",id:"advanced-configuration",level:2},{value:"Trusted Origins",id:"trusted-origins",level:3},{value:"Custom Error Handler",id:"custom-error-handler",level:3},{value:"Custom Storage/Database",id:"custom-storagedatabase",level:3},{value:"Token Management",id:"token-management",level:3},{value:"API Reference",id:"api-reference",level:2},{value:"Config Properties",id:"config-properties",level:2},{value:"Error Types",id:"error-types",level:2},{value:"Constants",id:"constants",level:2}];function d(e){let t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"csrf",children:"CSRF"})}),"\n",(0,s.jsxs)(t.p,{children:["The CSRF middleware protects against ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Cross-site_request_forgery",children:"Cross-Site Request Forgery"})," attacks by validating tokens on unsafe HTTP methods such as POST, PUT, and DELETE. It responds with 403 Forbidden when validation fails."]}),"\n",(0,s.jsx)(t.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#quick-start",children:"Quick Start"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#best-practices--production-requirements",children:"Best Practices & Production Requirements"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#configuration-by-application-type",children:"Configuration by Application Type"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#recipes-for-common-use-cases",children:"Recipes for Common Use Cases"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#using-csrf-tokens",children:"Using CSRF Tokens"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#security-model",children:"Security Model"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#token-extractors",children:"Token Extractors"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#advanced-configuration",children:"Advanced Configuration"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#api-reference",children:"API Reference"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#config-properties",children:"Config Properties"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#error-types",children:"Error Types"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#constants",children:"Constants"})}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"quick-start",children:"Quick Start"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'import (\n    "github.com/gofiber/fiber/v3"\n    "github.com/gofiber/fiber/v3/extractors"\n    "github.com/gofiber/fiber/v3/middleware/csrf"\n)\n\n// Default config (development only)\napp.Use(csrf.New())\n\n// Production config\napp.Use(csrf.New(csrf.Config{\n    CookieName:        "__Host-csrf_",\n    CookieSecure:      true,\n    CookieHTTPOnly:    true,  // false for SPAs\n    CookieSameSite:    "Lax",\n    CookieSessionOnly: true,\n    Extractor:         extractors.FromHeader("X-Csrf-Token"),\n    Session:           sessionStore,\n    // Redaction is enabled by default. Set DisableValueRedaction when you must expose tokens or storage keys in diagnostics.\n    // DisableValueRedaction: true,\n}))\n'})}),"\n",(0,s.jsx)(t.h2,{id:"best-practices--production-requirements",children:"Best Practices & Production Requirements"}),"\n",(0,s.jsx)(t.admonition,{title:"Production Requirements",type:"danger",children:(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"CookieSecure: true"})," (HTTPS only)"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:'CookieSameSite: "Lax"'})," or ",(0,s.jsx)(t.code,{children:'"Strict"'})]}),"\n",(0,s.jsxs)(t.li,{children:["Use ",(0,s.jsx)(t.code,{children:"Session"})," store for better security"]}),"\n"]})}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Always use HTTPS"})," in production"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Use sessions"})," for authenticated applications"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsxs)(t.strong,{children:["Set ",(0,s.jsx)(t.code,{children:"CookieSecure: true"})]})," and appropriate SameSite values"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Implement XSS protection"})," alongside CSRF"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Regenerate tokens"})," after auth changes"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsxs)(t.strong,{children:["Use ",(0,s.jsx)(t.code,{children:"__Host-"})," cookie prefix"]})," when possible"]}),"\n"]}),"\n",(0,s.jsx)(t.admonition,{title:"BREACH Protection",type:"warning",children:(0,s.jsx)(t.p,{children:"To mitigate BREACH attacks, ensure your pages are served over HTTPS, disable HTTP compression, and implement rate limiting for requests. The CSRF token is sent as a header on every request, so if you include the token in a page that is vulnerable to BREACH, an attacker may be able to extract the token."})}),"\n",(0,s.jsx)(t.h2,{id:"configuration-by-application-type",children:"Configuration by Application Type"}),"\n",(0,s.jsx)(t.h3,{id:"server-side-rendered-apps",children:"Server-Side Rendered Apps"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'app.Use(csrf.New(csrf.Config{\n    CookieName:        "__Host-csrf_",\n    CookieSecure:      true,\n    CookieHTTPOnly:    true,        // Secure - blocks JavaScript\n    CookieSameSite:    "Lax",\n    CookieSessionOnly: true,\n    Extractor:         extractors.FromForm("_csrf"),\n    Session:           sessionStore,\n}))\n'})}),"\n",(0,s.jsx)(t.h3,{id:"single-page-applications-spas",children:"Single Page Applications (SPAs)"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'app.Use(csrf.New(csrf.Config{\n    CookieName:        "__Host-csrf_",\n    CookieSecure:      true,\n    CookieHTTPOnly:    false,       // Required for JavaScript access to tokens\n    CookieSameSite:    "Lax",\n    CookieSessionOnly: true,\n    Extractor:         extractors.FromHeader("X-Csrf-Token"),\n    Session:           sessionStore,\n}))\n'})}),"\n",(0,s.jsx)(t.admonition,{title:"SPA Security Trade-off",type:"warning",children:(0,s.jsxs)(t.p,{children:["SPAs require ",(0,s.jsx)(t.code,{children:"CookieHTTPOnly: false"})," to access tokens via JavaScript. This slightly increases XSS risk but is necessary for SPA functionality."]})}),"\n",(0,s.jsx)(t.h2,{id:"recipes-for-common-use-cases",children:"Recipes for Common Use Cases"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Without Sessions"}),": ",(0,s.jsx)(t.a,{href:"https://github.com/gofiber/recipes/tree/master/csrf",children:"CSRF Recipe"})," - Simple Double Submit Cookie pattern"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"With Sessions"}),": ",(0,s.jsx)(t.a,{href:"https://github.com/gofiber/recipes/tree/master/csrf-with-session",children:"CSRF with Session Recipe"})," - More secure Synchronizer Token pattern"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"using-csrf-tokens",children:"Using CSRF Tokens"}),"\n",(0,s.jsx)(t.h3,{id:"server-side-forms",children:"Server-Side Forms"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'func formHandler(c fiber.Ctx) error {\n    token := csrf.TokenFromContext(c)\n\n    return c.SendString(fmt.Sprintf(`\n        <form method="POST" action="/submit">\n            <input type="hidden" name="_csrf" value="%s">\n            <input type="text" name="message" required>\n            <button type="submit">Submit</button>\n        </form>\n    `, token))\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"single-page-applications",children:"Single Page Applications"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'func apiHandler(c fiber.Ctx) error {\n    token := csrf.TokenFromContext(c)\n\n    return c.JSON(fiber.Map{\n        "csrf_token": token,\n        "data":       "your data",\n    })\n}\n'})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"// Get CSRF token from cookie\nfunction getCsrfToken() {\n    const value = `; ${document.cookie}`;\n    const parts = value.split(`; __Host-csrf_=`);\n    if (parts.length === 2) return parts.pop().split(';').shift();\n}\n\n// Use with fetch API\nasync function makeRequest(url, data) {\n    const csrfToken = getCsrfToken();\n\n    const response = await fetch(url, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            'X-Csrf-Token': csrfToken\n        },\n        body: JSON.stringify(data)\n    });\n\n    if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n\n    return response.json();\n}\n"})}),"\n",(0,s.jsx)(t.h2,{id:"security-model",children:"Security Model"}),"\n",(0,s.jsx)(t.p,{children:"The middleware employs a robust, defense-in-depth strategy to protect against CSRF attacks. The primary defense is token-based validation, which operates in one of two modes depending on your configuration. This is supplemented by a mandatory secondary check on the request's origin."}),"\n",(0,s.jsx)(t.h3,{id:"fetch-metadata-guardrails",children:"Fetch Metadata Guardrails"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Sec-Fetch-Site"}),": For unsafe methods, the middleware inspects the ",(0,s.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Site",children:(0,s.jsx)(t.code,{children:"Sec-Fetch-Site"})}),' header when present. If the header value is not one of "same-origin", "none", "same-site", or "cross-site", the request is rejected with ',(0,s.jsx)(t.code,{children:"ErrFetchSiteInvalid"}),". If the header is valid or absent, the request proceeds to the standard origin and token validation checks. This provides an early check to block requests with invalid ",(0,s.jsx)(t.code,{children:"Sec-Fetch-Site"})," values, while allowing legitimate same-site and cross-site requests to be validated by the existing mechanisms."]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"1-token-validation-patterns",children:"1. Token Validation Patterns"}),"\n",(0,s.jsx)(t.h4,{id:"double-submit-cookie-default-mode",children:"Double Submit Cookie (Default Mode)"}),"\n",(0,s.jsxs)(t.p,{children:["This is the default pattern, used when a ",(0,s.jsx)(t.code,{children:"Session"})," store is ",(0,s.jsx)(t.strong,{children:"not"}),' configured. It is a "semi-stateless" approach; while it doesn\'t tie tokens to a specific user session, the server still maintains a record of all validly issued tokens.']}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"How it Works:"})}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["On a user's first visit (or a safe request like ",(0,s.jsx)(t.code,{children:"GET"}),"), the middleware generates a unique token."]}),"\n",(0,s.jsxs)(t.li,{children:["This token is sent to the client in a ",(0,s.jsx)(t.code,{children:"Set-Cookie"})," header."]}),"\n",(0,s.jsxs)(t.li,{children:["The server also stores this token (in memory by default or in the configured ",(0,s.jsx)(t.code,{children:"Storage"}),"). It confirms the token is server-generated and still valid, but it is not tied to a specific user."]}),"\n",(0,s.jsxs)(t.li,{children:["For subsequent unsafe requests (e.g., ",(0,s.jsx)(t.code,{children:"POST"}),", ",(0,s.jsx)(t.code,{children:"PUT"}),"), the client must read the token from the cookie and echo it in a different location, such as the ",(0,s.jsx)(t.code,{children:"X-Csrf-Token"})," header."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Validation:"})," The middleware validates three things: that the token from the header/form ",(0,s.jsx)(t.strong,{children:"exactly matches"})," the token from the cookie, that the token ",(0,s.jsx)(t.strong,{children:"exists"})," in the server-side storage, and that it ",(0,s.jsx)(t.strong,{children:"has not expired"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Why it is secure:"})," Attackers on a malicious domain cannot read the victim's cookie to forge a matching header. They also cannot invent a token because it wouldn't exist in the server's storage registry."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.h4,{id:"synchronizer-token-session-based-mode",children:"Synchronizer Token (Session-Based Mode)"}),"\n",(0,s.jsxs)(t.p,{children:["This is a more secure, stateful pattern that is ",(0,s.jsx)(t.strong,{children:"automatically enabled"})," when you provide a ",(0,s.jsx)(t.code,{children:"Session"})," store in the configuration."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"How it Works:"})}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"A unique token is generated and stored directly within the user's session data on the server."}),"\n",(0,s.jsx)(t.li,{children:"The token is also sent to the client as a cookie."}),"\n",(0,s.jsx)(t.li,{children:"For unsafe requests, the client sends the token back in a header or form field."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Validation:"})," The middleware performs a multi-step validation:"]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["It first performs the standard ",(0,s.jsx)(t.strong,{children:"Double Submit Cookie check"}),": the token from the header/form must exactly match the token from the cookie. This is a fast and efficient first line of defense, and there is little benefit of skipping it."]}),"\n",(0,s.jsxs)(t.li,{children:["It then validates that this token exists and is valid within the user's ",(0,s.jsx)(t.strong,{children:"server-side session"}),". This is the authoritative check that ties the token to the authenticated user."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Why it is more secure:"})," Tying the token to the server-side session provides the strongest CSRF protection, as the token is then guaranteed to have been generated for the specific user. While browsers automatically send the required cookie, custom API clients must remember to include the cookie with their requests for validation to succeed."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:"// Enable the more secure Synchronizer Token pattern\napp.Use(csrf.New(csrf.Config{\n    Session: sessionStore, // Providing a session store activates this mode\n}))\n"})}),"\n",(0,s.jsx)(t.h3,{id:"2-origin--referer-validation",children:"2. Origin & Referer Validation"}),"\n",(0,s.jsxs)(t.p,{children:["As a crucial second layer of defense, the middleware ",(0,s.jsx)(t.strong,{children:"always"})," performs ",(0,s.jsx)(t.code,{children:"Origin"})," and ",(0,s.jsx)(t.code,{children:"Referer"})," header checks for unsafe requests (when the connection is HTTPS)."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["The request's ",(0,s.jsx)(t.code,{children:"Origin"})," (for cross-origin requests) or ",(0,s.jsx)(t.code,{children:"Referer"})," (for same-origin requests) header ",(0,s.jsx)(t.strong,{children:"must"})," match the application's ",(0,s.jsx)(t.code,{children:"Host"})," header or be explicitly allowed in the ",(0,s.jsx)(t.code,{children:"TrustedOrigins"})," list."]}),"\n",(0,s.jsxs)(t.li,{children:["This check is performed ",(0,s.jsx)(t.em,{children:"in addition"})," to token validation and provides strong protection because these headers are reliably set by browsers and cannot be programmatically controlled by an attacker from a malicious site."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"token-extractors",children:"Token Extractors"}),"\n",(0,s.jsxs)(t.p,{children:["This middleware uses the shared ",(0,s.jsx)(t.code,{children:"extractors"})," package for token extraction. For full details on extractor types, chaining, security, and advanced usage, see the ",(0,s.jsx)(t.a,{href:"../guide/extractors",children:"Extractors Guide"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Extractor Source Constants:"}),"\nExtractor source constants (such as ",(0,s.jsx)(t.code,{children:"SourceHeader"}),", ",(0,s.jsx)(t.code,{children:"SourceForm"}),", etc.) are defined in the shared extractors package, not in the CSRF middleware itself. Refer to the Extractors Guide for their definitions and usage."]}),"\n",(0,s.jsx)(t.h3,{id:"csrf-specific-extractor-notes",children:"CSRF-Specific Extractor Notes"}),"\n",(0,s.jsx)(t.p,{children:"For CSRF protection, prefer secure extraction methods:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Headers"})," (",(0,s.jsx)(t.code,{children:'extractors.FromHeader("X-Csrf-Token")'}),") \u2013 Most secure, not logged in URLs"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Form data"})," (",(0,s.jsx)(t.code,{children:'extractors.FromForm("_csrf")'}),") \u2013 Secure for form submissions"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Avoid URL parameters"})," \u2013 Query/param extractors expose tokens in logs and browser history"]}),"\n"]}),"\n",(0,s.jsxs)(t.admonition,{title:"What about cookies?",type:"note",children:[(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Cookies are generally not a secure source for CSRF tokens."})," The middleware will panic if you configure an extractor that reads from cookies with the same name as your CSRF cookie. This is because reading the CSRF token from a cookie with the same name as the CSRF cookie defeats CSRF protection entirely, as the extracted token will always match the cookie value, allowing any CSRF attack to succeed."]}),(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Advanced usage:"}),"\nIn rare cases, you may securely extract a CSRF token from a cookie if:"]}),(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"You read from a different cookie (not the CSRF cookie itself)"}),"\n",(0,s.jsx)(t.li,{children:"You use multiple cookies for custom validation"}),"\n",(0,s.jsx)(t.li,{children:"You implement custom logic across different cookie sources"}),"\n"]}),(0,s.jsxs)(t.p,{children:["If you do this, set the extractor\u2019s ",(0,s.jsx)(t.code,{children:"Source"})," to ",(0,s.jsx)(t.code,{children:"SourceCookie"})," and allow the middleware to check that the cookie name is different from your CSRF cookie. It will panic if this is the case."]}),(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Warning:"}),"\nCookie-based extraction is strongly discouraged, as it is easy to misconfigure and creates security risks. Prefer extracting tokens from headers or form fields for robust CSRF protection. See the ",(0,s.jsx)(t.a,{href:"../guide/extractors#security-considerations",children:"Extractors Guide"})," for more details."]})]}),"\n",(0,s.jsx)(t.h3,{id:"route-specific-configuration",children:"Route-Specific Configuration"}),"\n",(0,s.jsx)(t.p,{children:"You can configure different extraction methods for different routes:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'// API routes - header extraction for AJAX/fetch requests\napi := app.Group("/api")\napi.Use(csrf.New(csrf.Config{\n    Extractor: extractors.FromHeader("X-Csrf-Token"),\n}))\n\n// Form routes - form field extraction for traditional forms\nforms := app.Group("/forms")\nforms.Use(csrf.New(csrf.Config{\n    Extractor: extractors.FromForm("_csrf"),\n}))\n'})}),"\n",(0,s.jsx)(t.h3,{id:"custom-csrf-extractors",children:"Custom CSRF Extractors"}),"\n",(0,s.jsxs)(t.p,{children:["For specialized CSRF token extraction needs, you can create custom extractors. See the ",(0,s.jsx)(t.a,{href:"../guide/extractors#custom-extraction-logic",children:"Extractors Guide"})," for advanced patterns and security notes."]}),"\n",(0,s.jsxs)(t.admonition,{title:"Never Extract from Cookies",type:"danger",children:[(0,s.jsxs)(t.p,{children:[(0,s.jsxs)(t.strong,{children:["NEVER create custom extractors that read from cookies using the same ",(0,s.jsx)(t.code,{children:"CookieName"})," as your CSRF configuration."]})," This completely defeats CSRF protection by making the extracted token always match the cookie value, allowing any CSRF attack to succeed."]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'// \u274C NEVER DO THIS - Completely defeats CSRF protection\nbadExtractor := csrf.Extractor{\n    Extract: func(c fiber.Ctx) (string, error) {\n        return c.Cookies("csrf_"), nil  // Always passes validation!\n    },\n    Source: csrf.SourceCustom, // See extractors.SourceCustom in shared package\n    Key:    "csrf_",\n}\n\n// \u2705 DO THIS - Extract from different source than cookie\napp.Use(csrf.New(csrf.Config{\n    CookieName: "csrf_",\n    Extractor: extractors.FromHeader("X-Csrf-Token"), // Header vs cookie comparison\n}))\n'})}),(0,s.jsxs)(t.p,{children:["The middleware uses the ",(0,s.jsx)(t.strong,{children:"Double Submit Cookie"})," pattern \u2013 it compares the extracted token against the cookie value. If you configure an extractor that reads from the same cookie, it will panic because they will always match and provide zero CSRF protection."]})]}),"\n",(0,s.jsx)(t.h4,{id:"bearer-token-embedding--custom-extractors",children:"Bearer Token Embedding & Custom Extractors"}),"\n",(0,s.jsxs)(t.p,{children:["You can create advanced extractors for use cases like JWT embedding or JSON body parsing. See the ",(0,s.jsx)(t.a,{href:"../guide/extractors#custom-extraction-logic",children:"Extractors Guide"})," for secure implementation patterns and more examples."]}),"\n",(0,s.jsx)(t.h3,{id:"fallback-extraction",children:"Fallback Extraction"}),"\n",(0,s.jsx)(t.p,{children:"For applications that need to support both AJAX and form submissions:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'// Try header first (AJAX), fall back to form (traditional forms)\napp.Use(csrf.New(csrf.Config{\n    Extractor: extractors.Chain(\n        extractors.FromHeader("X-Csrf-Token"),\n        extractors.FromForm("_csrf"),\n    ),\n}))\n'})}),"\n",(0,s.jsx)(t.admonition,{type:"warning",children:(0,s.jsxs)(t.p,{children:["Chaining extractors increases complexity. Use only when you need to support multiple client types. See the ",(0,s.jsx)(t.a,{href:"../guide/extractors#chain-ordering-strategy",children:"Extractors Guide"})," for details and security notes."]})}),"\n",(0,s.jsx)(t.h2,{id:"advanced-configuration",children:"Advanced Configuration"}),"\n",(0,s.jsx)(t.h3,{id:"trusted-origins",children:"Trusted Origins"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'app.Use(csrf.New(csrf.Config{\n    TrustedOrigins: []string{\n        "https://trusted.example.com",\n        "https://*.example.com", // Wildcard subdomains\n    },\n}))\n'})}),"\n",(0,s.jsx)(t.h3,{id:"custom-error-handler",children:"Custom Error Handler"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'app.Use(csrf.New(csrf.Config{\n    ErrorHandler: func(c fiber.Ctx, err error) error {\n        accepts := c.Accepts("html", "json")\n        path := c.Path()\n        if accepts == "json" || strings.HasPrefix(path, "/api/") {\n            return c.Status(fiber.StatusForbidden).JSON(fiber.Map{\n                "error": "Forbidden",\n            })\n        }\n        return c.Status(fiber.StatusForbidden).Render("error", fiber.Map{\n            "Title": "Forbidden",\n            "Status": fiber.StatusForbidden,\n        }, "layouts/main")\n    },\n}))\n'})}),"\n",(0,s.jsx)(t.h3,{id:"custom-storagedatabase",children:"Custom Storage/Database"}),"\n",(0,s.jsxs)(t.p,{children:["You can use any storage from our ",(0,s.jsx)(t.a,{href:"https://github.com/gofiber/storage/",children:"storage"})," package."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:"storage := sqlite3.New() // From github.com/gofiber/storage/sqlite3\napp.Use(csrf.New(csrf.Config{\n    Storage: storage,\n}))\n"})}),"\n",(0,s.jsx)(t.h3,{id:"token-management",children:"Token Management"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:"// Delete token (e.g., on logout)\nhandler := csrf.HandlerFromContext(c)\nif handler != nil {\n    if err := handler.DeleteToken(c); err != nil {\n        // handle error, e.g. log it\n    }\n}\n\n// With session middleware\n// Destroying the session will also remove the CSRF token if using session-based CSRF.\nsession.Destroy()\n"})}),"\n",(0,s.jsx)(t.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:"// Create middleware\nfunc New(config ...csrf.Config) fiber.Handler\n\n// Get token from context\nfunc TokenFromContext(c fiber.Ctx) string\n\n// Get handler from context\nfunc HandlerFromContext(c fiber.Ctx) *csrf.Handler\n\n// Delete token\nfunc (h *csrf.Handler) DeleteToken(c fiber.Ctx) error\n"})}),"\n",(0,s.jsx)(t.h2,{id:"config-properties",children:"Config Properties"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Property"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Type"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Description"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Default"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Next"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"func(fiber.Ctx) bool"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Skip middleware when returns true"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"nil"})})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"CookieName"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"string"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"CSRF cookie name"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:'"csrf_"'})})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"CookieDomain"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"string"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"CSRF cookie domain"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:'""'})})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"CookiePath"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"string"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"CSRF cookie path"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:'""'})})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"CookieSecure"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"bool"})}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["HTTPS only cookie (",(0,s.jsx)(t.strong,{children:"required for production"}),")"]}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"false"})})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"CookieHTTPOnly"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"bool"})}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["Prevent JavaScript access (",(0,s.jsxs)(t.strong,{children:["use ",(0,s.jsx)(t.code,{children:"false"})," for SPAs"]}),")"]}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"false"})})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"CookieSameSite"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"string"})}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["SameSite attribute (",(0,s.jsx)(t.strong,{children:'use "Lax" or "Strict"'}),")"]}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:'"Lax"'})})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"CookieSessionOnly"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"bool"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Session-only cookie (expires on browser close)"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"false"})})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"IdleTimeout"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"time.Duration"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Token expiration time"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"30 * time.Minute"})})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"KeyGenerator"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"func() string"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Token generation function"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"utils.SecureToken"})})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"ErrorHandler"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"fiber.ErrorHandler"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Custom error handler"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"defaultErrorHandler"})})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Extractor"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"extractors.Extractor"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Token extraction method with metadata"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:'extractors.FromHeader("X-Csrf-Token")'})})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"DisableValueRedaction"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"bool"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Disables redaction of tokens and storage keys in logs and error messages."}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"false"})})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Session"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"*session.Store"})}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["Session store (",(0,s.jsx)(t.strong,{children:"recommended for production"}),")"]}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"nil"})})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Storage"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"fiber.Storage"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Token storage (overridden by Session)"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"nil"})})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"TrustedOrigins"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"[]string"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Trusted origins for cross-origin requests"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"[]"})})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"SingleUseToken"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"bool"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Generate new token after each use"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"false"})})]})]})]}),"\n",(0,s.jsx)(t.h2,{id:"error-types",children:"Error Types"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'var (\n    ErrTokenNotFound   = errors.New("csrf: token not found")\n    ErrTokenInvalid    = errors.New("csrf: token invalid")\n    ErrRefererNotFound = errors.New("csrf: referer header missing")\n    ErrRefererInvalid  = errors.New("csrf: referer header invalid")\n    ErrRefererNoMatch  = errors.New("csrf: referer does not match host or trusted origins")\n    ErrOriginInvalid   = errors.New("csrf: origin header invalid")\n    ErrOriginNoMatch   = errors.New("csrf: origin does not match host or trusted origins")\n)\n'})}),"\n",(0,s.jsx)(t.h2,{id:"constants",children:"Constants"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'const (\n    HeaderName = "X-Csrf-Token"\n)\n'})})]})}function h(e={}){let{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},84429:function(e,t,n){n.d(t,{R:()=>o,x:()=>l});var r=n(96540);let s={},i=r.createContext(s);function o(e){let t=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);