"use strict";(self.webpackChunkfiber_docs=self.webpackChunkfiber_docs||[]).push([["36607"],{44621:function(e){e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"fiber-v3-extractors-guide","metadata":{"permalink":"/blog/fiber-v3-extractors-guide","editUrl":"https://github.com/gofiber/docs/tree/master/blog/2026-02-21-fiber-v3-extractors-guide.md","source":"@site/blog/2026-02-21-fiber-v3-extractors-guide.md","title":"Extractors Guide for Middleware","description":"Use extractors to centralize value extraction across middleware and improve security consistency.","date":"2026-02-21T00:00:00.000Z","tags":[{"inline":true,"label":"fiber","permalink":"/blog/tags/fiber"},{"inline":true,"label":"v3","permalink":"/blog/tags/v-3"},{"inline":true,"label":"extractors","permalink":"/blog/tags/extractors"},{"inline":true,"label":"middleware","permalink":"/blog/tags/middleware"},{"inline":true,"label":"security","permalink":"/blog/tags/security"},{"inline":true,"label":"go","permalink":"/blog/tags/go"}],"readingTime":5.84,"hasTruncateMarker":true,"authors":[{"name":"Fiber Team","title":"Maintainers","url":"https://github.com/gofiber/fiber","imageURL":"https://github.com/gofiber.png","key":"fiber-team","page":null}],"frontMatter":{"slug":"fiber-v3-extractors-guide","title":"Extractors Guide for Middleware","authors":["fiber-team"],"tags":["fiber","v3","extractors","middleware","security","go"],"description":"Use extractors to centralize value extraction across middleware and improve security consistency."},"unlisted":false,"nextItem":{"title":"Hooks Guide for Clean Lifecycles","permalink":"/blog/fiber-v3-hooks-guide"}},"content":"Security bugs in middleware are often not algorithm bugs. They are extraction-policy bugs.\\n\\nOne component reads bearer tokens from headers, another falls back to query parameters first, a third uses cookie-first behavior. Each of these can work in isolation, but together they create inconsistent security posture. During an auth migration, the problem multiplies: old services use one extraction path, new services use another, and nobody is sure which fallback order is actually active in production.\\n\\nThe extractors package in Fiber v3 exists to solve this. It gives middleware a shared, composable API for declaring where values come from and in what order, so extraction policy is explicit and reviewable rather than scattered across handler code.\\n\\n\x3c!-- truncate --\x3e\\n\\n## The Problem Extractors Replace\\n\\nBefore this package existed, every middleware that needed a token, session ID, or API key implemented its own extraction logic. KeyAuth had its own header parser. Session middleware had its own cookie reader. CSRF had its own form-field lookup. The logic was similar but never identical, and the differences were hard to spot in review.\\n\\nWhen a team wanted to change extraction behavior, say adding a fallback from header to cookie during a migration, they had to patch each middleware individually. If one middleware was missed, that endpoint silently used different extraction rules than the rest.\\n\\nExtractors consolidate this into a single package with a consistent API. Middleware packages import extractors directly, so changes to extraction logic propagate everywhere at once.\\n\\n## Available Extractors\\n\\nThe package provides extractors for every common HTTP source:\\n\\n- `FromAuthHeader(authScheme)` \u2014 extracts from the `Authorization` header, validating the scheme\\n- `FromHeader(key)` \u2014 extracts from any request header\\n- `FromCookie(key)` \u2014 extracts from HTTP cookies\\n- `FromQuery(param)` \u2014 extracts from URL query parameters\\n- `FromParam(param)` \u2014 extracts from URL path parameters\\n- `FromForm(param)` \u2014 extracts from form data (POST body)\\n- `FromCustom(key, fn)` \u2014 defines custom extraction logic with a callback\\n- `Chain(extractors...)` \u2014 tries multiple extractors in order, returns the first success\\n\\nEach extractor returns a struct with metadata about the source, not just the value. This means middleware can inspect where a value came from and make security decisions based on source type.\\n\\n## Basic Usage\\n\\nThe simplest case is a single-source extractor passed to middleware config:\\n\\n```go\\napp.Use(keyauth.New(keyauth.Config{\\n    Extractor: extractors.FromHeader(\\"X-API-Key\\"),\\n}))\\n```\\n\\nThis replaces whatever internal header-parsing logic the middleware previously used, with a shared implementation that behaves identically across all middleware.\\n\\nFor session middleware, the pattern is the same:\\n\\n```go\\napp.Use(session.New(session.Config{\\n    Extractor: extractors.FromCookie(\\"session_id\\"),\\n}))\\n```\\n\\n## Fallback Chains: Declaring Extraction Policy\\n\\nThe real power shows up when you need multiple sources. During auth migrations, for example, you might accept tokens from the `Authorization` header (the new path) while still supporting a legacy `X-API-Key` header and a query parameter fallback for internal tools.\\n\\n```go\\napp.Use(keyauth.New(keyauth.Config{\\n    Extractor: extractors.Chain(\\n        extractors.FromAuthHeader(\\"Bearer\\"),\\n        extractors.FromHeader(\\"X-API-Key\\"),\\n        extractors.FromQuery(\\"api_key\\"),\\n    ),\\n}))\\n```\\n\\n`Chain` tries each extractor in order. The first one that returns a non-empty value without error wins. If all extractors fail, it returns the last error or `ErrNotFound`.\\n\\nThe ordering is policy. Putting the `Authorization` header first means that if both a header and a query parameter are present, the header wins. That is a deliberate security decision, and it lives in code rather than in documentation that nobody reads.\\n\\n## Authorization Header and RFC Compliance\\n\\nThe `FromAuthHeader` extractor is not a simple string split. It implements RFC 9110 Section 11.6.2 and RFC 7235 token68 validation:\\n\\n- Case-insensitive scheme matching (`Bearer`, `bearer`, `BEARER` all work)\\n- Strict whitespace handling (only spaces between scheme and token, no tabs)\\n- Token68 character validation (only `A-Z`, `a-z`, `0-9`, `-._~+/=`)\\n- Padding rules (trailing `=` only, never leading or mid-token)\\n\\n```go\\nextractor := extractors.FromAuthHeader(\\"Bearer\\")\\n\\n// Valid: \\"Bearer abc123\\" \u2192 \\"abc123\\"\\n// Valid: \\"bearer ABC123\\" \u2192 \\"ABC123\\" (case-insensitive)\\n// Invalid: \\"Bearer abc def\\" \u2192 rejected (space in token)\\n// Invalid: \\"Bearer =abc\\" \u2192 rejected (padding at start)\\n// Invalid: \\"Bearertoken\\" \u2192 rejected (no space after scheme)\\n```\\n\\nThis strictness matters because malformed authorization headers are a common vector for authentication bypass. A permissive parser might accept a header that a standards-compliant proxy would reject, creating inconsistency between your application layer and your infrastructure.\\n\\nIf you need raw header access without validation, pass an empty scheme:\\n\\n```go\\nraw := extractors.FromAuthHeader(\\"\\")\\n// Returns the full header value without scheme parsing\\n```\\n\\n## Security Considerations by Source\\n\\nDifferent extraction sources have different security properties, and the choice is not just about convenience.\\n\\n**Headers** are generally preferred for sensitive values. They are not visible in URLs, not stored in browser history, and not logged by default in most proxy configurations. The `Authorization` header is the standard place for credentials.\\n\\n**Cookies** are designed for persistent client-side storage and support `Secure`, `HttpOnly`, and `SameSite` flags. They are the right choice for session tokens, but require correct flag configuration to be safe.\\n\\n**Query parameters** are always visible in URLs. They get logged by servers, stored in browser history, cached by proxies, and appear in referrer headers. Never put sensitive tokens in query parameters unless there is no alternative.\\n\\n**Form data** is suitable for user-generated content and CSRF tokens in form submissions, but requires POST requests and correct content types.\\n\\nWhen building chains, order them from most secure to least secure:\\n\\n```go\\nextractors.Chain(\\n    extractors.FromAuthHeader(\\"Bearer\\"),    // standard, secure\\n    extractors.FromCookie(\\"auth_token\\"),    // persistent, needs flags\\n    extractors.FromQuery(\\"token\\"),          // visible, use sparingly\\n)\\n```\\n\\n## CSRF Middleware Example\\n\\nCSRF protection is a good example of where chains solve a real problem. Header-based CSRF tokens work for AJAX and API clients, but traditional form submissions need form-field extraction:\\n\\n```go\\napp.Use(csrf.New(csrf.Config{\\n    Extractor: extractors.Chain(\\n        extractors.FromHeader(\\"X-CSRF-Token\\"),\\n        extractors.FromForm(\\"_csrf\\"),\\n    ),\\n}))\\n```\\n\\nThis supports both JavaScript clients that set headers and HTML forms that submit tokens in hidden fields, with a single consistent config.\\n\\n## Custom Extractors for Special Cases\\n\\nWhen standard extractors do not fit, `FromCustom` lets you define arbitrary extraction logic:\\n\\n```go\\nextractor := extractors.FromCustom(\\"computed-token\\", func(c fiber.Ctx) (string, error) {\\n    if val := c.Locals(\\"computed_token\\"); val != nil {\\n        return val.(string), nil\\n    }\\n    return \\"\\", extractors.ErrNotFound\\n})\\n```\\n\\nCustom extractors break source awareness: middleware cannot determine where the value came from, so automatic security warnings and source-based logging will not work. Use them only when standard extractors do not meet your needs and you have evaluated the security implications.\\n\\n## Coordinating Multiple Middleware\\n\\nWhen several middleware packages extract values from the same request, make sure they use different sources to avoid conflicts:\\n\\n```go\\n// Good: different sources for different purposes\\napp.Use(keyauth.New(keyauth.Config{\\n    Extractor: extractors.FromHeader(\\"X-API-Key\\"),\\n}))\\napp.Use(session.New(session.Config{\\n    Extractor: extractors.FromCookie(\\"session_id\\"),\\n}))\\n```\\n\\nIf two middleware packages extract from the same cookie or header, one will shadow the other and debugging becomes unpredictable.\\n\\n## Where to Start\\n\\nIf your middleware currently uses hardcoded extraction logic, pick the authentication middleware first. Replace its internal token lookup with an extractor, then verify that fallback behavior matches what you expect. Once that works, move to session and CSRF middleware.\\n\\nThe goal is not to rewrite everything at once. The goal is to make extraction policy visible and consistent, one middleware at a time.\\n\\n## Internal References\\n\\n- [Extractors Guide](/guide/extractors)\\n- [KeyAuth Middleware](/middleware/keyauth)\\n- [What\'s New](/whats_new)"},{"id":"fiber-v3-hooks-guide","metadata":{"permalink":"/blog/fiber-v3-hooks-guide","editUrl":"https://github.com/gofiber/docs/tree/master/blog/2026-02-20-fiber-v3-hooks-guide.md","source":"@site/blog/2026-02-20-fiber-v3-hooks-guide.md","title":"Hooks Guide for Clean Lifecycles","description":"Use hooks to control startup, shutdown, and operational lifecycle more reliably.","date":"2026-02-20T00:00:00.000Z","tags":[{"inline":true,"label":"fiber","permalink":"/blog/tags/fiber"},{"inline":true,"label":"v3","permalink":"/blog/tags/v-3"},{"inline":true,"label":"hooks","permalink":"/blog/tags/hooks"},{"inline":true,"label":"lifecycle","permalink":"/blog/tags/lifecycle"},{"inline":true,"label":"operations","permalink":"/blog/tags/operations"},{"inline":true,"label":"go","permalink":"/blog/tags/go"}],"readingTime":4.7,"hasTruncateMarker":true,"authors":[{"name":"Fiber Team","title":"Maintainers","url":"https://github.com/gofiber/fiber","imageURL":"https://github.com/gofiber.png","key":"fiber-team","page":null}],"frontMatter":{"slug":"fiber-v3-hooks-guide","title":"Hooks Guide for Clean Lifecycles","authors":["fiber-team"],"tags":["fiber","v3","hooks","lifecycle","operations","go"],"description":"Use hooks to control startup, shutdown, and operational lifecycle more reliably."},"unlisted":false,"prevItem":{"title":"Extractors Guide for Middleware","permalink":"/blog/fiber-v3-extractors-guide"},"nextItem":{"title":"Handler Compatibility in the New Router","permalink":"/blog/fiber-v3-adapter-pattern"}},"content":"Many runtime incidents happen during transitions, not steady state.\\n\\nA service is starting up, shutting down, draining workers, or flushing telemetry, and behavior is only partially defined. If your deploy process relies on conventions like \\"we always flush metrics before exit,\\" but nobody enforced that in code, you get data loss during rollouts. If startup checks happen in scattered goroutines, a failing dependency might not block listen, and you serve errors for the first few seconds after deploy.\\n\\nFiber v3 hooks give that lifecycle a concrete structure. Instead of hoping everyone follows the same script, you can register pre and post handlers for startup and shutdown and make the behavior reviewable.\\n\\n\x3c!-- truncate --\x3e\\n\\n## What v2 Lifecycle Looked Like\\n\\nIn v2, the main lifecycle hook was `OnShutdown`. It ran during server shutdown, but you had no way to distinguish \\"before the server stops accepting\\" from \\"after everything is drained.\\" Teams often worked around this with manual signal handling:\\n\\n```go\\n// v2-era pattern: manual signal handling outside Fiber\\nquit := make(chan os.Signal, 1)\\nsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\\n\\ngo func() {\\n    <-quit\\n    log.Println(\\"stopping workers...\\") // hope this runs before Shutdown\\n    stopConsumers()\\n    app.Shutdown()\\n}()\\n\\napp.Listen(\\":3000\\")\\n```\\n\\nThe problem was ordering. You could not guarantee that worker drain happened before or after the server stopped, and the shutdown error was invisible unless you wired it yourself.\\n\\nv3 replaces `OnShutdown` with explicit `OnPreShutdown` and `OnPostShutdown` hooks, and adds startup message hooks that give you a real contract for each phase.\\n\\n## Startup Message Customization\\n\\nOne of the most practical additions is the ability to customize the startup banner. In production, the default Fiber banner is noise. In staging, you want environment context visible immediately when a pod starts.\\n\\n```go\\napp := fiber.New()\\n\\napp.Hooks().OnPreStartupMessage(func(sm *fiber.PreStartupMessageData) error {\\n    sm.BannerHeader = \\"MY-SERVICE \\" + sm.Version + \\"\\\\n-------\\"\\n\\n    sm.AddInfo(\\"region\\", \\"Region\\", os.Getenv(\\"AWS_REGION\\"))\\n    sm.AddInfo(\\"release\\", \\"Release\\", os.Getenv(\\"RELEASE_SHA\\"))\\n    sm.AddWarning(\\"debug\\", \\"Debug mode\\", \\"enabled\\")\\n    return nil\\n})\\n\\napp.Hooks().OnPostStartupMessage(func(sm *fiber.PostStartupMessageData) error {\\n    if !sm.Disabled && !sm.IsChild && !sm.Prevented {\\n        log.Println(\\"startup banner printed, service ready\\")\\n    }\\n    return nil\\n})\\n```\\n\\nInside `OnPreStartupMessage` you have full control:\\n\\n- `sm.BannerHeader` replaces the ASCII art banner\\n- `sm.AddInfo`, `sm.AddWarning`, `sm.AddError` add labeled entries\\n- `sm.ResetEntries()` clears all default entries if you want a clean slate\\n- `sm.PreventDefault = true` suppresses the banner entirely without affecting other hooks\\n\\nThe `PostStartupMessageData` gives you flags to check whether the banner was actually printed (`Disabled`, `IsChild`, `Prevented`), so you can gate post-startup logic accordingly.\\n\\n## Shutdown Hooks with Clear Phases\\n\\nThe shutdown hooks split a single event into two phases with different responsibilities:\\n\\n```go\\napp.Hooks().OnPreShutdown(func() error {\\n    log.Println(\\"pre-shutdown: stop accepting new work\\")\\n    return stopConsumers()\\n})\\n\\napp.Hooks().OnPostShutdown(func(err error) error {\\n    if err != nil {\\n        log.Printf(\\"shutdown had errors: %v\\", err)\\n        alertOps(err)\\n    }\\n    return flushMetrics()\\n})\\n```\\n\\n`OnPreShutdown` runs before the server finishes shutting down. This is where you stop queue consumers, cancel background workers, and drain in-flight requests.\\n\\n`OnPostShutdown` runs after the server is down and receives the shutdown error. This is where you flush metrics, close database pools, and send final telemetry. The error parameter tells you whether shutdown was clean or not, so you can adjust your cleanup accordingly.\\n\\nImportant: when using shutdown hooks, `app.Listen()` must run in a goroutine so `app.Shutdown()` is reachable:\\n\\n```go\\ngo app.Listen(\\":3000\\")\\n// ... signal handling ...\\napp.Shutdown()\\n```\\n\\n## Route and Group Registration Hooks\\n\\nBeyond lifecycle, Fiber v3 also provides hooks that fire during route registration. These are useful for building route registries, auto-generating documentation, or enforcing naming conventions at startup time.\\n\\n```go\\napp.Hooks().OnRoute(func(r fiber.Route) error {\\n    log.Printf(\\"registered: %s %s\\", r.Method, r.Path)\\n    return nil\\n})\\n\\napp.Hooks().OnGroup(func(g fiber.Group) error {\\n    log.Printf(\\"group registered: %s\\", g.Prefix)\\n    return nil\\n})\\n```\\n\\n`OnName` fires when a route is named via `.Name()`, which is useful for building route registries or logging named routes:\\n\\n```go\\napp.Hooks().OnName(func(r fiber.Route) error {\\n    log.Printf(\\"named route registered: %s %s \u2192 %s\\", r.Method, r.Path, r.Name)\\n    return nil\\n})\\n\\napp.Get(\\"/users\\", listUsers).Name(\\"listUsers\\")\\n```\\n\\nIf you want to enforce that *all* routes have names, use `OnRoute` instead \u2014 it fires for every registration regardless of whether `.Name()` was called:\\n\\n```go\\napp.Hooks().OnRoute(func(r fiber.Route) error {\\n    if r.Name == \\"\\" {\\n        return fmt.Errorf(\\"route %s %s must have a name\\", r.Method, r.Path)\\n    }\\n    return nil\\n})\\n```\\n\\n## Mount Hooks for Sub-Applications\\n\\nWhen you compose applications from sub-apps, `OnMount` fires after a child app is mounted. The callback receives the parent app, so you can inspect or modify the parent during composition:\\n\\n```go\\napi := fiber.New()\\napi.Hooks().OnMount(func(parent *fiber.App) error {\\n    log.Printf(\\"api mounted at: %s\\", parent.MountPath())\\n    return nil\\n})\\n\\napp.Use(\\"/api\\", api)\\n```\\n\\nThis is useful for plugin-style architectures where sub-apps need to register shared middleware or verify parent configuration before they start serving.\\n\\n## Putting It Together: A Production Lifecycle\\n\\nHere is what a realistic lifecycle setup looks like when you combine several hooks:\\n\\n```mermaid\\nflowchart TD\\n    A[\\"App starts\\"] --\x3e B[\\"OnPreStartupMessage: set banner + env info\\"]\\n    B --\x3e C[\\"Fiber prints startup banner\\"]\\n    C --\x3e D[\\"OnPostStartupMessage: log startup complete\\"]\\n    D --\x3e E[\\"Serving requests\\"]\\n    E --\x3e F[\\"Shutdown signal received\\"]\\n    F --\x3e G[\\"OnPreShutdown: drain workers, stop consumers\\"]\\n    G --\x3e H[\\"Server stops accepting connections\\"]\\n    H --\x3e I[\\"OnPostShutdown: flush metrics, close pools\\"]\\n```\\n\\nThe key insight is that each phase has a clear owner. You can review lifecycle behavior in a pull request the same way you review business logic, because it lives in code with explicit ordering.\\n\\n## Where to Start\\n\\nIf your service currently has no lifecycle hooks, start with two:\\n\\n1. `OnPreShutdown` to drain background work before exit\\n2. `OnPostShutdown` to flush telemetry and confirm clean shutdown\\n\\nThat alone eliminates the most common class of deploy-related data loss. Once that works, add startup message customization so your team can see environment context in logs without grepping for it.\\n\\n## Internal References\\n\\n- [Hooks API](/api/hooks)\\n- [What\'s New](/whats_new)"},{"id":"fiber-v3-adapter-pattern","metadata":{"permalink":"/blog/fiber-v3-adapter-pattern","editUrl":"https://github.com/gofiber/docs/tree/master/blog/2026-02-19-fiber-v3-adapter-pattern.md","source":"@site/blog/2026-02-19-fiber-v3-adapter-pattern.md","title":"Handler Compatibility in the New Router","description":"How Fiber\'s new router compatibility layer lets you use Fiber, net/http, and fasthttp handlers side by side.","date":"2026-02-19T00:00:00.000Z","tags":[{"inline":true,"label":"fiber","permalink":"/blog/tags/fiber"},{"inline":true,"label":"v3","permalink":"/blog/tags/v-3"},{"inline":true,"label":"router","permalink":"/blog/tags/router"},{"inline":true,"label":"handler","permalink":"/blog/tags/handler"},{"inline":true,"label":"compatibility","permalink":"/blog/tags/compatibility"},{"inline":true,"label":"migration","permalink":"/blog/tags/migration"},{"inline":true,"label":"go","permalink":"/blog/tags/go"}],"readingTime":5.12,"hasTruncateMarker":true,"authors":[{"name":"Fiber Team","title":"Maintainers","url":"https://github.com/gofiber/fiber","imageURL":"https://github.com/gofiber.png","key":"fiber-team","page":null}],"frontMatter":{"slug":"fiber-v3-adapter-pattern","title":"Handler Compatibility in the New Router","authors":["fiber-team"],"tags":["fiber","v3","router","handler","compatibility","migration","go"],"description":"How Fiber\'s new router compatibility layer lets you use Fiber, net/http, and fasthttp handlers side by side."},"unlisted":false,"prevItem":{"title":"Hooks Guide for Clean Lifecycles","permalink":"/blog/fiber-v3-hooks-guide"},"nextItem":{"title":"RFC Conformance in Practice","permalink":"/blog/fiber-v3-rfc-conformance"}},"content":"One of the most underrated improvements in the v3 router is not a new method or fancy syntax. It is **handler compatibility**.\\n\\nIn plain terms: Fiber can now accept multiple handler styles directly, and the router compatibility layer adapts them for you. That sounds small until you are migrating a real codebase with hundreds of handlers, middleware functions, and utility packages in different styles. Then it becomes the feature that decides whether migration happens this quarter or gets postponed again.\\n\\n\x3c!-- truncate --\x3e\\n\\n## The Migration Problem This Solves\\n\\nMost teams do not start from a greenfield codebase. They have `net/http` handlers written years ago, `fasthttp` handlers from performance-critical paths, middleware contracts in various styles, and helper functions that mix handler signatures.\\n\\nBefore this compatibility model, migration usually meant one of two painful paths:\\n\\n- Rewrite all handler signatures upfront, even when business logic had not changed. This creates a large, risky PR that touches every endpoint.\\n- Maintain local custom adapters that wrap old handlers. These wrappers are inconsistent across modules, and nobody cleans them up after migration.\\n\\nBoth approaches increase risk and slow down migration. The v3 compatibility layer eliminates this tradeoff by accepting supported handler shapes directly in the router.\\n\\n## Supported Handler Styles\\n\\nThe router adapter understands 17 handler signatures across four families:\\n\\n**Native Fiber handlers** \u2014 the cleanest long-term choice:\\n\\n```go\\napp.Get(\\"/health\\", func(c fiber.Ctx) error {\\n    return c.SendString(\\"ok\\")\\n})\\n```\\n\\n**Standard library `net/http` handlers** \u2014 for legacy code and ecosystem packages:\\n\\n```go\\nmux := http.NewServeMux()\\nmux.HandleFunc(\\"/legacy\\", func(w http.ResponseWriter, r *http.Request) {\\n    w.WriteHeader(http.StatusOK)\\n    _, _ = w.Write([]byte(\\"legacy route\\"))\\n})\\n\\napp.Get(\\"/legacy\\", mux.ServeHTTP)\\n```\\n\\nThis is especially useful when one route still depends on old middleware or legacy packages that only expose `http.Handler` interfaces.\\n\\n**`fasthttp` handlers** \u2014 for existing performance-critical code:\\n\\n```go\\napp.Get(\\"/fast\\", func(ctx *fasthttp.RequestCtx) {\\n    ctx.SetStatusCode(fasthttp.StatusOK)\\n    _, _ = ctx.WriteString(\\"fast path\\")\\n})\\n```\\n\\n**Express-style `Req`/`Res` handlers** \u2014 for teams migrating from Express or who prefer that mental model:\\n\\n```go\\napp.Use(func(req fiber.Req, res fiber.Res, next func() error) error {\\n    res.Set(\\"X-Trace-Source\\", \\"compat-layer\\")\\n    return next()\\n})\\n\\napp.Get(\\"/hello\\", func(req fiber.Req, res fiber.Res) {\\n    _ = res.SendString(\\"hello\\")\\n})\\n```\\n\\nThe Express-style callbacks support both two-argument (handler) and three-argument (middleware with `next`) forms, with or without error returns. The adapter also supports `next` callbacks that accept errors (`func(error)` or `func(error) error`), so middleware control flow works across all styles.\\n\\n## How `next` Wiring Works\\n\\nA subtle but important detail is how `next` is connected across handler styles. When you use optional `next` callbacks in Express-style handlers, Fiber wires them to `c.Next()` internally:\\n\\n- Calling `next(nil)` (or `next()` for the no-argument variant) continues the middleware chain\\n- Passing a non-nil error to `next(err)` short-circuits and returns that error\\n- If your handler returns an `error`, the value returned from the injected `next()` bubbles straight back to the caller\\n\\nThis means middleware behavior follows expected control flow even when handlers use different signature styles. A `net/http` middleware and an Express-style middleware in the same chain will propagate errors consistently.\\n\\n## RouteChain: Express-style Route Declaration\\n\\nBeyond handler compatibility, the v3 router also adds `RouteChain`, a helper inspired by [Express\'s `app.route()`](https://expressjs.com/en/api.html#app.route) that lets you declare multiple HTTP methods on the same path without repeating it:\\n\\n```go\\napp.RouteChain(\\"/api\\").RouteChain(\\"/user/:id?\\").\\n    Get(func(c fiber.Ctx) error {\\n        return c.JSON(fiber.Map{\\"action\\": \\"get user\\", \\"id\\": c.Params(\\"id\\")})\\n    }).\\n    Post(func(c fiber.Ctx) error {\\n        return c.JSON(fiber.Map{\\"action\\": \\"create user\\"})\\n    }).\\n    Put(func(c fiber.Ctx) error {\\n        return c.JSON(fiber.Map{\\"action\\": \\"update user\\", \\"id\\": c.Params(\\"id\\")})\\n    }).\\n    Delete(func(c fiber.Ctx) error {\\n        return c.JSON(fiber.Map{\\"action\\": \\"delete user\\", \\"id\\": c.Params(\\"id\\")})\\n    })\\n```\\n\\nThis is particularly clean for resource-style APIs where GET, POST, PUT, and DELETE all operate on the same path.\\n\\n## Automatic HEAD Routes\\n\\nFiber v3 auto-registers a `HEAD` route for every `GET` route. The generated handler chain matches the `GET` chain, so status codes and headers stay in sync while the response body remains empty:\\n\\n```go\\napp.Get(\\"/health\\", func(c fiber.Ctx) error {\\n    c.Set(\\"X-Service\\", \\"api\\")\\n    return c.SendString(\\"OK\\")\\n})\\n\\n// HEAD /health automatically returns headers without body\\n```\\n\\nYou can still register explicit `HEAD` handlers to override the generated ones, and you can disable this entirely with `fiber.Config{DisableHeadAutoRegister: true}` if you prefer to manage HEAD routes yourself.\\n\\n## Stricter Middleware Prefix Matching\\n\\nThe v3 router aligns middleware registration closer to Express. Prefix matching is now stricter: partial matches must end at a slash boundary or be an exact match. This prevents `/api` middleware from accidentally running on `/apiv1`:\\n\\n```go\\n// This middleware only runs for /api and /api/... paths\\n// It does NOT run for /apiv1 or /api-internal\\napp.Use(\\"/api\\", apiMiddleware)\\n```\\n\\nYou can also register middleware for multiple prefixes at once:\\n\\n```go\\napp.Use([]string{\\"/v1\\", \\"/v2\\"}, func(c fiber.Ctx) error {\\n    return c.Next()\\n})\\n```\\n\\nAnd sub-apps can be mounted with `app.Use()` instead of the old `app.Mount()`:\\n\\n```go\\napi := fiber.New()\\napi.Get(\\"/users\\", listUsers)\\n\\napp.Use(\\"/api\\", api)\\n```\\n\\n## A Practical Migration Pattern\\n\\nA migration pattern that works well in real teams:\\n\\n1. **Keep legacy routes operational** using compatibility handlers. Register existing `net/http` or `fasthttp` handlers directly in the Fiber router. No wrappers needed.\\n2. **Migrate high-traffic routes first** to native Fiber handlers. These benefit most from Fiber-specific APIs like binding, custom context, and hooks.\\n3. **Remove compatibility paths** once ownership and test coverage are stable.\\n\\n```mermaid\\nflowchart LR\\n    A[\\"Legacy net/http handlers\\"] --\x3e B[\\"Register via compatibility layer\\"]\\n    B --\x3e C[\\"Run alongside native Fiber handlers\\"]\\n    C --\x3e D[\\"Migrate route by route\\"]\\n    D --\x3e E[\\"All native Fiber handlers\\"]\\n```\\n\\nThe important point is that compatibility is a **transition tool**, not a permanent architecture target. Native Fiber handlers are the right long-term choice for hot paths, new endpoints, and code that uses Fiber-specific context APIs.\\n\\n## When to Prefer Native Fiber Immediately\\n\\nEven with compatibility support, choose native Fiber handlers for:\\n\\n- New endpoints (no legacy code to preserve)\\n- Performance-sensitive paths (native handlers avoid adapter overhead)\\n- Code that needs binding, custom context, or hooks\\n\\nUse compatibility where it reduces migration risk, not where it increases long-term complexity.\\n\\n## Internal References\\n\\n- Official section: [What\'s New: Handler compatibility](/whats_new#handler-compatibility)\\n- API docs: [App Router Methods](/api/app)\\n- Middleware docs: [Adaptor Middleware](/middleware/adaptor)"},{"id":"fiber-v3-rfc-conformance","metadata":{"permalink":"/blog/fiber-v3-rfc-conformance","editUrl":"https://github.com/gofiber/docs/tree/master/blog/2026-02-18-fiber-v3-rfc-conformance.md","source":"@site/blog/2026-02-18-fiber-v3-rfc-conformance.md","title":"RFC Conformance in Practice","description":"Why RFC-aligned behavior matters for interoperability, caching, and security.","date":"2026-02-18T00:00:00.000Z","tags":[{"inline":true,"label":"fiber","permalink":"/blog/tags/fiber"},{"inline":true,"label":"v3","permalink":"/blog/tags/v-3"},{"inline":true,"label":"rfc","permalink":"/blog/tags/rfc"},{"inline":true,"label":"http","permalink":"/blog/tags/http"},{"inline":true,"label":"security","permalink":"/blog/tags/security"},{"inline":true,"label":"go","permalink":"/blog/tags/go"}],"readingTime":5.32,"hasTruncateMarker":true,"authors":[{"name":"Fiber Team","title":"Maintainers","url":"https://github.com/gofiber/fiber","imageURL":"https://github.com/gofiber.png","key":"fiber-team","page":null}],"frontMatter":{"slug":"fiber-v3-rfc-conformance","title":"RFC Conformance in Practice","authors":["fiber-team"],"tags":["fiber","v3","rfc","http","security","go"],"description":"Why RFC-aligned behavior matters for interoperability, caching, and security."},"unlisted":false,"prevItem":{"title":"Handler Compatibility in the New Router","permalink":"/blog/fiber-v3-adapter-pattern"},"nextItem":{"title":"Custom Context in Practice","permalink":"/blog/fiber-v3-custom-context"}},"content":"RFC conformance can sound abstract until you run a real production stack.\\n\\nYour service is not only interacting with one client. It is sitting behind load balancers, reverse proxies, CDNs, API gateways, browsers, mobile clients, and internal automation tools. A cookie that works in Chrome but breaks in Safari, a cache header that your CDN interprets differently than you intended, an authorization header that your proxy strips because it does not match the expected format \u2014 these are real incidents that happen because of small protocol deviations.\\n\\nFiber v3 addresses this with specific improvements to cookie handling, context behavior, response semantics, and connection management, each tied to concrete RFCs. This post walks through what changed and why it matters operationally.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Cookie Security: SameSite=None and Automatic Secure Flag\\n\\nModern browsers (Chrome, Firefox, Safari) reject cookies that set `SameSite=None` without the `Secure` flag. This is required by RFC 6265bis and enforced by all major browsers since 2020.\\n\\nIn v2, teams had to remember to set both flags manually. Forgetting `Secure` on a cross-site cookie was a silent failure: the cookie just disappeared in the browser without any server-side error.\\n\\nFiber v3 enforces this automatically. When you set `SameSite=None`, Fiber sets `Secure=true` for you:\\n\\n```go\\nc.Cookie(&fiber.Cookie{\\n    Name:     \\"session\\",\\n    Value:    token,\\n    HTTPOnly: true,\\n    SameSite: \\"None\\",\\n    // Secure is automatically set to true by Fiber\\n})\\n```\\n\\nThis eliminates an entire class of \\"cookies don\'t work in production but work locally\\" bugs, because local development typically uses HTTP while production uses HTTPS.\\n\\n## CHIPS: Partitioned Cookies for Privacy\\n\\nFiber v3 also supports Partitioned cookies for [CHIPS](https://developers.google.com/privacy-sandbox/3pcd/chips) (Cookies Having Independent Partitioned State). This is a newer browser feature that partitions cookies by top-level site, preventing cross-site tracking while still allowing legitimate third-party cookie use.\\n\\n```go\\nc.Cookie(&fiber.Cookie{\\n    Name:        \\"widget_session\\",\\n    Value:       token,\\n    HTTPOnly:    true,\\n    Secure:      true,\\n    SameSite:    \\"None\\",\\n    Partitioned: true,\\n})\\n```\\n\\nIf your service embeds widgets, authentication flows, or tracking pixels in third-party sites, partitioned cookies let you maintain session state without being blocked by third-party cookie restrictions. Without CHIPS support, these use cases break progressively as browsers roll out stricter cookie policies.\\n\\n## Context Implements context.Context\\n\\nOne of the more subtle but impactful changes: `fiber.Ctx` now implements Go\'s standard `context.Context` interface. This means you can pass the Fiber context directly to functions that expect a `context.Context`, including database drivers, HTTP clients, and tracing libraries.\\n\\nIn v2, you had to use `c.UserContext()` and `c.SetUserContext()` to bridge between Fiber and the standard library:\\n\\n```go\\n// v2: manual context bridging\\nctx := c.UserContext()\\nrows, err := db.QueryContext(ctx, \\"SELECT ...\\")\\n```\\n\\nIn v3, the context is the context:\\n\\n```go\\n// v3: Fiber context is a context.Context\\nrows, err := db.QueryContext(c, \\"SELECT ...\\")\\n```\\n\\nThis matters for deadline propagation, cancellation, and request-scoped values. Libraries that accept `context.Context` now get proper request lifecycle integration without boilerplate. If a request is cancelled, the context signals it. If a deadline is set, downstream calls respect it.\\n\\nYou can still set a base context with `c.SetContext()` if you need to inject values or deadlines before passing `c` to downstream code. And `c.Context()` returns a `context.Context` that is safe to use outside the handler scope.\\n\\n## SendEarlyHints: HTTP 103 for Resource Preloading\\n\\nFiber v3 supports [HTTP 103 Early Hints](https://developer.chrome.com/docs/web-platform/early-hints), an informational response that lets the server send `Link` headers before the final response is ready. This allows browsers to start preloading critical assets while the server is still computing the response.\\n\\n```go\\napp.Get(\\"/dashboard\\", func(c fiber.Ctx) error {\\n    hints := []string{\\n        \\"<https://cdn.example.com/app.js>; rel=preload; as=script\\",\\n        \\"<https://cdn.example.com/style.css>; rel=preload; as=style\\",\\n    }\\n    if err := c.SendEarlyHints(hints); err != nil {\\n        return err\\n    }\\n\\n    // expensive computation or DB query here\\n    data := loadDashboard()\\n    return c.JSON(data)\\n})\\n```\\n\\nFor pages with heavy asset loads, early hints can measurably improve perceived load time because the browser starts fetching CSS and JavaScript while the server is still preparing HTML or API data.\\n\\nNote: older HTTP/1.1 clients may ignore or mishandle 103 responses. This is most effective with HTTP/2 and HTTP/3 deployments.\\n\\n## Drop: Silent Connection Termination\\n\\nThe `Drop` method terminates a client connection without sending any HTTP response. No headers, no status code, no body. The client sees a connection reset.\\n\\n```go\\napp.Use(func(c fiber.Ctx) error {\\n    if isBlocked(c.IP()) {\\n        return c.Drop()\\n    }\\n    return c.Next()\\n})\\n```\\n\\nThis is useful for DDoS mitigation and endpoint protection where you want to reveal as little information as possible to the attacker. A normal 403 or 429 response confirms the endpoint exists and tells the attacker their request reached the application layer. `Drop` gives them nothing.\\n\\nThis should complement, not replace, infrastructure-level protections like firewalls and rate limiters. But for application-layer blocking, it is a meaningful improvement over returning error responses.\\n\\n## End: Immediate Connection Flush\\n\\nThe `End` method, modeled after Express.js `res.end()`, immediately flushes the response and closes the connection. Any middleware that runs after the handler cannot modify the response:\\n\\n```go\\napp.Get(\\"/webhook\\", func(c fiber.Ctx) error {\\n    c.SendString(\\"accepted\\")\\n    return c.End() // response is sent, connection closed\\n    // downstream middleware cannot change the response\\n})\\n```\\n\\nThis is useful for webhook endpoints and fire-and-forget patterns where you want to acknowledge the request immediately without risking response modification from error-handling middleware.\\n\\n## Non-ASCII Filenames in Downloads\\n\\nFiber v3 now uses `filename*` encoding per [RFC 6266](https://www.rfc-editor.org/rfc/rfc6266) and [RFC 8187](https://www.rfc-editor.org/rfc/rfc8187) for non-ASCII filenames in `Attachment` and `Download` responses. This means filenames with Unicode characters render correctly in all modern browsers instead of being garbled or replaced with fallback names.\\n\\n## Where to Apply This After Upgrading\\n\\nA practical first step after migrating to v3 is a response-policy audit:\\n\\n1. **Cookies**: Review all `Set-Cookie` calls. Confirm that cross-site cookies use `SameSite=None` (v3 handles `Secure` automatically). Consider `Partitioned` for third-party contexts.\\n2. **Cache headers**: Verify cache behavior matches your CDN and proxy expectations. The [cache middleware](/middleware/cache) updates in v3 align more closely with standard semantics.\\n3. **Auth headers**: If you use the extractors package, the `FromAuthHeader` extractor now validates tokens per RFC 9110 and RFC 7235.\\n4. **Download endpoints**: Test with non-ASCII filenames to confirm proper encoding.\\n\\nTeams that do this audit once usually prevent an entire class of \\"works in one client but not another\\" incidents.\\n\\n## Internal References\\n\\n- [What\'s New](/whats_new)\\n- [Ctx API](/api/ctx)\\n- [Cache Middleware](/middleware/cache)\\n- [Static Middleware](/middleware/static)"},{"id":"fiber-v3-custom-context","metadata":{"permalink":"/blog/fiber-v3-custom-context","editUrl":"https://github.com/gofiber/docs/tree/master/blog/2026-02-17-fiber-v3-custom-context.md","source":"@site/blog/2026-02-17-fiber-v3-custom-context.md","title":"Custom Context in Practice","description":"Extend context safely with NewWithCustomCtx for cleaner handler code.","date":"2026-02-17T00:00:00.000Z","tags":[{"inline":true,"label":"fiber","permalink":"/blog/tags/fiber"},{"inline":true,"label":"v3","permalink":"/blog/tags/v-3"},{"inline":true,"label":"context","permalink":"/blog/tags/context"},{"inline":true,"label":"architecture","permalink":"/blog/tags/architecture"},{"inline":true,"label":"go","permalink":"/blog/tags/go"}],"readingTime":3.96,"hasTruncateMarker":true,"authors":[{"name":"Fiber Team","title":"Maintainers","url":"https://github.com/gofiber/fiber","imageURL":"https://github.com/gofiber.png","key":"fiber-team","page":null}],"frontMatter":{"slug":"fiber-v3-custom-context","title":"Custom Context in Practice","authors":["fiber-team"],"tags":["fiber","v3","context","architecture","go"],"description":"Extend context safely with NewWithCustomCtx for cleaner handler code."},"unlisted":false,"prevItem":{"title":"RFC Conformance in Practice","permalink":"/blog/fiber-v3-rfc-conformance"},"nextItem":{"title":"Binding in Practice","permalink":"/blog/fiber-v3-binding-in-practice"}},"content":"As backend services mature, handlers start repeating the same request plumbing over and over again. Tenant resolution, actor identification, correlation values, access-scoped metadata. None of this is business logic, but all of it is required before any business logic can run.\\n\\nIn a typical multi-tenant API, every handler opens with five or six lines of header extraction and default-value logic. When that logic is duplicated across fifty endpoints, small inconsistencies creep in. One handler reads `X-Tenant-ID`, another reads `X-TenantID`, a third falls back to a query parameter. Custom context gives that plumbing a single, typed home.\\n\\n\x3c!-- truncate --\x3e\\n\\n## How Teams Solved This in v2\\n\\nIn v2, the most common pattern was a combination of middleware setting `c.Locals()` values and helper functions extracting them:\\n\\n```go\\n// v2: middleware sets locals\\nfunc TenantMiddleware(c *fiber.Ctx) error {\\n    tenantID := c.Get(\\"X-Tenant-ID\\")\\n    if tenantID == \\"\\" {\\n        tenantID = \\"public\\"\\n    }\\n    c.Locals(\\"tenantID\\", tenantID)\\n    return c.Next()\\n}\\n\\n// v2: helper function reads locals\\nfunc GetTenantID(c *fiber.Ctx) string {\\n    if v, ok := c.Locals(\\"tenantID\\").(string); ok {\\n        return v\\n    }\\n    return \\"public\\"\\n}\\n\\n// v2: every handler calls the helper\\napp.Get(\\"/data\\", func(c *fiber.Ctx) error {\\n    tenantID := GetTenantID(c)\\n    // ...\\n})\\n```\\n\\nThis worked, but it had problems. The `Locals` key was a string, so typos were silent failures. The helper function lived in a utility package that handlers had to import. The type assertion could fail. And nothing prevented a handler from reading locals directly with a different key, bypassing the helper entirely.\\n\\nOver time, teams ended up with multiple helper packages, inconsistent naming, and no compile-time guarantee that the right metadata was available.\\n\\n## How v3 Custom Context Works\\n\\n`NewWithCustomCtx` lets you define a typed context struct that embeds `fiber.DefaultCtx` and adds application-specific methods. The methods are available on every handler\'s context without imports, casts, or string keys:\\n\\n```go\\ntype AppCtx struct {\\n    fiber.DefaultCtx\\n}\\n\\nfunc (c *AppCtx) TenantID() string {\\n    return c.Get(\\"X-Tenant-ID\\", \\"public\\")\\n}\\n\\nfunc (c *AppCtx) ActorID() string {\\n    return c.Get(\\"X-Actor-ID\\", \\"anonymous\\")\\n}\\n\\nfunc (c *AppCtx) RequestID() string {\\n    return c.Get(\\"X-Request-ID\\")\\n}\\n\\napp := fiber.NewWithCustomCtx(func(app *fiber.App) fiber.CustomCtx {\\n    return &AppCtx{DefaultCtx: *fiber.NewDefaultCtx(app)}\\n})\\n```\\n\\nHandlers use a type assertion to access the custom methods:\\n\\n```go\\napp.Get(\\"/whoami\\", func(c fiber.Ctx) error {\\n    cc := c.(*AppCtx)\\n    return c.JSON(fiber.Map{\\n        \\"tenant\\": cc.TenantID(),\\n        \\"actor\\":  cc.ActorID(),\\n        \\"reqID\\":  cc.RequestID(),\\n    })\\n})\\n```\\n\\nThe type assertion is the only boilerplate. Everything else \u2014 header reading, default values, naming conventions \u2014 lives in one place and is enforced by the compiler.\\n\\n## Why This Matters for Multi-Tenant Systems\\n\\nIn a multi-tenant API, almost every database query, cache key, and audit log entry needs a tenant identifier. If that identifier comes from a helper function that can be forgotten, you get data leaks (queries without tenant scope) or audit gaps (log entries without tenant context).\\n\\nWith custom context, the method is always available and always returns a consistent value. You can also add computed properties that combine multiple request values:\\n\\n```go\\nfunc (c *AppCtx) AuditContext() map[string]string {\\n    return map[string]string{\\n        \\"tenant\\":  c.TenantID(),\\n        \\"actor\\":   c.ActorID(),\\n        \\"request\\": c.RequestID(),\\n        \\"ip\\":      c.IP(),\\n    }\\n}\\n```\\n\\nAudit logging then becomes a single call instead of four separate extractions per handler.\\n\\n## What Belongs in Custom Context\\n\\nCustom context should be a boundary helper, not a domain layer. Good candidates:\\n\\n- Request metadata extraction (tenant, actor, correlation IDs)\\n- Header convenience methods with defaults\\n- Request-scoped computed properties (audit maps, permission flags)\\n- Common response patterns (standard error envelopes)\\n\\nWhat does **not** belong in custom context:\\n\\n- Database access or repository calls\\n- Business logic or validation rules\\n- Heavy computation that should live in a service layer\\n\\nKeep the context thin. If a method needs more than the request itself to do its work, it probably belongs in a service package that receives the context as a parameter.\\n\\n## Testing Custom Context\\n\\nSince custom context methods only depend on the request, they are easy to test with `app.Test()`:\\n\\n```go\\napp := fiber.NewWithCustomCtx(func(app *fiber.App) fiber.CustomCtx {\\n    return &AppCtx{DefaultCtx: *fiber.NewDefaultCtx(app)}\\n})\\n\\napp.Get(\\"/test\\", func(c fiber.Ctx) error {\\n    cc := c.(*AppCtx)\\n    return c.JSON(fiber.Map{\\"tenant\\": cc.TenantID()})\\n})\\n\\nreq := httptest.NewRequest(\\"GET\\", \\"/test\\", nil)\\nreq.Header.Set(\\"X-Tenant-ID\\", \\"acme\\")\\n\\nresp, _ := app.Test(req)\\n// resp body contains {\\"tenant\\":\\"acme\\"}\\n```\\n\\nNo mocking, no dependency injection for the context layer itself. The custom methods are pure request readers.\\n\\n## Migrating from Locals to Custom Context\\n\\nIf your v2 codebase uses `Locals` for request metadata, the migration path is straightforward:\\n\\n1. Define an `AppCtx` struct with methods that replace each `Locals` key\\n2. Initialize the app with `NewWithCustomCtx`\\n3. Replace `GetTenantID(c)` calls with `c.(*AppCtx).TenantID()`\\n4. Remove the middleware that set locals (the custom method reads headers directly)\\n5. Remove the helper packages\\n\\nThe result is fewer moving parts: no middleware setting values, no helpers reading them, no string keys that can drift.\\n\\n## Internal References\\n\\n- [App API](/api/app)\\n- [Ctx API](/api/ctx)\\n- [What\'s New](/whats_new)"},{"id":"fiber-v3-binding-in-practice","metadata":{"permalink":"/blog/fiber-v3-binding-in-practice","editUrl":"https://github.com/gofiber/docs/tree/master/blog/2026-02-16-fiber-v3-binding-in-practice.md","source":"@site/blog/2026-02-16-fiber-v3-binding-in-practice.md","title":"Binding in Practice","description":"Use Bind methods to make request handling consistent and easier to maintain.","date":"2026-02-16T00:00:00.000Z","tags":[{"inline":true,"label":"fiber","permalink":"/blog/tags/fiber"},{"inline":true,"label":"v3","permalink":"/blog/tags/v-3"},{"inline":true,"label":"binding","permalink":"/blog/tags/binding"},{"inline":true,"label":"api","permalink":"/blog/tags/api"},{"inline":true,"label":"go","permalink":"/blog/tags/go"}],"readingTime":5.57,"hasTruncateMarker":true,"authors":[{"name":"Fiber Team","title":"Maintainers","url":"https://github.com/gofiber/fiber","imageURL":"https://github.com/gofiber.png","key":"fiber-team","page":null}],"frontMatter":{"slug":"fiber-v3-binding-in-practice","title":"Binding in Practice","authors":["fiber-team"],"tags":["fiber","v3","binding","api","go"],"description":"Use Bind methods to make request handling consistent and easier to maintain."},"unlisted":false,"prevItem":{"title":"Custom Context in Practice","permalink":"/blog/fiber-v3-custom-context"},"nextItem":{"title":"New Client Deep Dive","permalink":"/blog/fiber-v3-client-deep-dive"}},"content":"Request parsing is one of the easiest places to create hidden technical debt.\\n\\nAt the beginning of a project, mixed parsing styles seem harmless. A quick `c.Query()` here, a manual `json.Unmarshal(c.Body(), &req)` there, a `c.Params()` somewhere else. After enough endpoints, input behavior becomes unpredictable. One handler parses the body with a JSON decoder, another uses form tags, a third reads query parameters with individual calls. When bugs appear, you have to trace parsing logic per endpoint instead of trusting a shared convention.\\n\\nFiber v3 binding exists to make that convention explicit. `c.Bind()` is not just a new method name. It is a structured API that supports every input source, has defined precedence rules, integrates validation, and supports custom decoders. If your team agrees on binding, input handling stops being a source of surprises.\\n\\n\x3c!-- truncate --\x3e\\n\\n## What v2 Parsing Looked Like\\n\\nIn v2, request data parsing used individual methods on the context:\\n\\n```go\\n// v2: scattered parsing methods\\nfunc handler(c *fiber.Ctx) error {\\n    name := c.Query(\\"name\\")\\n    id, _ := c.ParamsInt(\\"id\\")\\n\\n    var body RequestBody\\n    if err := c.BodyParser(&body); err != nil {\\n        return err\\n    }\\n\\n    role := c.Get(\\"X-Role\\")\\n    session := c.Cookies(\\"session_id\\")\\n    // ...\\n}\\n```\\n\\nEach source had its own method, its own error behavior, and its own conventions. Teams that worked across many endpoints often ended up with inconsistent parsing: some handlers used `BodyParser`, others called `json.Unmarshal` directly, and a few mixed query and body parsing without clear precedence.\\n\\nv3 replaces these with a unified binding API where you declare the source explicitly and the framework handles parsing, type conversion, and validation.\\n\\n## Focused Source Binding\\n\\nThe most readable pattern is binding from a single, specific source:\\n\\n```go\\ntype ListUsersQuery struct {\\n    Page  int    `query:\\"page\\"`\\n    Limit int    `query:\\"limit\\"`\\n    Sort  string `query:\\"sort\\"`\\n}\\n\\napp.Get(\\"/users\\", func(c fiber.Ctx) error {\\n    q := new(ListUsersQuery)\\n    if err := c.Bind().Query(q); err != nil {\\n        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\\"error\\": err.Error()})\\n    }\\n\\n    return c.JSON(fiber.Map{\\"query\\": q})\\n})\\n```\\n\\nThis pattern makes intent obvious: this endpoint only cares about query input. The struct tags document the source, and the `Bind().Query()` call makes parsing explicit in the handler.\\n\\nThe same pattern works for every source:\\n\\n- `c.Bind().Body(out)` \u2014 JSON, XML, form, multipart, MsgPack, CBOR (content-type auto-detected)\\n- `c.Bind().Query(out)` \u2014 URL query parameters\\n- `c.Bind().Header(out)` \u2014 request headers\\n- `c.Bind().Cookie(out)` \u2014 cookies\\n- `c.Bind().URI(out)` \u2014 URL path parameters\\n\\n## Multi-Source Binding with `Bind().All()`\\n\\nWhen an endpoint needs data from multiple sources, `All()` binds from every source with a defined precedence:\\n\\n```go\\ntype UserInput struct {\\n    ID    int    `uri:\\"id\\" json:\\"id\\" query:\\"id\\"`\\n    Name  string `json:\\"name\\" form:\\"name\\" query:\\"name\\"`\\n    Role  string `header:\\"X-Role\\"`\\n    Token string `cookie:\\"session_token\\"`\\n}\\n\\napp.Post(\\"/users/:id\\", func(c fiber.Ctx) error {\\n    in := new(UserInput)\\n    if err := c.Bind().All(in); err != nil {\\n        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\\"error\\": err.Error()})\\n    }\\n\\n    return c.JSON(in)\\n})\\n```\\n\\nThe precedence order is fixed by the framework:\\n\\n1. URI parameters\\n2. Request body\\n3. Query parameters\\n4. Headers\\n5. Cookies\\n\\nThat means if the same field name appears in both the URI and the query string, the URI value wins. This is a framework contract, not something you have to remember or document per handler. It removes a class of ambiguity bugs in mixed-source endpoints.\\n\\n## Built-in Validation\\n\\nBinding integrates with struct validation. You configure a validator once at app level, then every binding call runs validation automatically:\\n\\n```go\\nimport \\"github.com/go-playground/validator/v10\\"\\n\\ntype structValidator struct {\\n    validate *validator.Validate\\n}\\n\\nfunc (v *structValidator) Validate(out any) error {\\n    return v.validate.Struct(out)\\n}\\n\\napp := fiber.New(fiber.Config{\\n    StructValidator: &structValidator{validate: validator.New()},\\n})\\n```\\n\\nNow your input structs can use `validate` tags:\\n\\n```go\\ntype CreateUser struct {\\n    Name  string `json:\\"name\\" validate:\\"required\\"`\\n    Email string `json:\\"email\\" validate:\\"required,email\\"`\\n    Age   int    `json:\\"age\\" validate:\\"gte=18,lte=120\\"`\\n}\\n\\napp.Post(\\"/users\\", func(c fiber.Ctx) error {\\n    u := new(CreateUser)\\n    if err := c.Bind().Body(u); err != nil {\\n        // includes both parse errors and validation errors\\n        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\\"error\\": err.Error()})\\n    }\\n\\n    return c.JSON(u)\\n})\\n```\\n\\nThe validation runs after parsing, so a single `Bind().Body()` call handles both deserialization and validation. No separate validation step, no risk of forgetting to validate in one handler.\\n\\n## Default Values\\n\\nBinding supports default values via the `default` struct tag. This is useful for pagination and optional filters:\\n\\n```go\\ntype SearchQuery struct {\\n    Page     int      `query:\\"page,default:1\\"`\\n    Limit    int      `query:\\"limit,default:20\\"`\\n    Tags     []string `query:\\"tags,default:latest|featured\\"`\\n}\\n\\napp.Get(\\"/search\\", func(c fiber.Ctx) error {\\n    q := new(SearchQuery)\\n    if err := c.Bind().Query(q); err != nil {\\n        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\\"error\\": err.Error()})\\n    }\\n\\n    // q.Page is 1 if not provided, q.Tags is [\\"latest\\", \\"featured\\"]\\n    return c.JSON(q)\\n})\\n```\\n\\nDefaults are applied before validation, so a field with a default value will pass `required` validation even if the client did not send it. Slice defaults use `|` as separator.\\n\\n## Custom Binders for Non-Standard Formats\\n\\nIf your API accepts formats beyond JSON, XML, and form data, you can register custom binders. A YAML binder, for example:\\n\\n```go\\ntype yamlBinder struct{}\\n\\nfunc (y *yamlBinder) Name() string          { return \\"yaml\\" }\\nfunc (y *yamlBinder) MIMETypes() []string   { return []string{\\"application/yaml\\"} }\\nfunc (y *yamlBinder) Parse(c fiber.Ctx, out any) error {\\n    return yaml.Unmarshal(c.Body(), out)\\n}\\n\\napp.RegisterCustomBinder(&yamlBinder{})\\n```\\n\\nOnce registered, `Bind().Body()` auto-detects `application/yaml` content and uses your binder. You can also call it explicitly with `Bind().Custom(\\"yaml\\", &out)`.\\n\\n## CBOR and MsgPack Support\\n\\nFiber v3 natively supports [CBOR](https://cbor.io/) and [MsgPack](https://msgpack.org/) in addition to JSON, XML, and form data. These binary formats are more compact and faster to parse, which makes them practical for high-throughput internal APIs:\\n\\n```go\\ntype Event struct {\\n    Type string `json:\\"type\\" msgpack:\\"type\\" cbor:\\"type\\"`\\n    Data []byte `json:\\"data\\" msgpack:\\"data\\" cbor:\\"data\\"`\\n}\\n\\napp.Post(\\"/events\\", func(c fiber.Ctx) error {\\n    e := new(Event)\\n    if err := c.Bind().Body(e); err != nil {\\n        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\\"error\\": err.Error()})\\n    }\\n\\n    return c.JSON(e)\\n})\\n```\\n\\nThe correct binder is selected automatically based on the `Content-Type` header. No handler changes are needed to support multiple formats.\\n\\n## A Handler Shape That Scales\\n\\nA stable pattern across all endpoints is: bind input, validate, execute logic, map response.\\n\\n```mermaid\\nflowchart LR\\n    A[\\"Request arrives\\"] --\x3e B[\\"c.Bind parses input\\"]\\n    B --\x3e C{\\"Validation passes?\\"}\\n    C -- no --\x3e D[\\"Return 400 with error\\"]\\n    C -- yes --\x3e E[\\"Execute business logic\\"]\\n    E --\x3e F[\\"Return JSON response\\"]\\n```\\n\\nWhen every endpoint follows this shape, onboarding gets easier and reviews become faster because the structure is predictable. If someone adds a handler that skips binding or validates differently, it stands out immediately.\\n\\n## Where to Start\\n\\nStart with endpoints that currently parse from multiple sources (path + body + header). They get the biggest reliability gain from moving to explicit binding. Then add a struct validator to catch input errors before they reach business logic.\\n\\n## Internal References\\n\\n- [Bind API](/api/bind)\\n- [Ctx API](/api/ctx)\\n- [What\'s New](/whats_new)"},{"id":"fiber-v3-client-deep-dive","metadata":{"permalink":"/blog/fiber-v3-client-deep-dive","editUrl":"https://github.com/gofiber/docs/tree/master/blog/2026-02-15-fiber-v3-client-deep-dive.md","source":"@site/blog/2026-02-15-fiber-v3-client-deep-dive.md","title":"New Client Deep Dive","description":"How to use the new Fiber client package for reliable service-to-service communication.","date":"2026-02-15T00:00:00.000Z","tags":[{"inline":true,"label":"fiber","permalink":"/blog/tags/fiber"},{"inline":true,"label":"v3","permalink":"/blog/tags/v-3"},{"inline":true,"label":"client","permalink":"/blog/tags/client"},{"inline":true,"label":"http","permalink":"/blog/tags/http"},{"inline":true,"label":"go","permalink":"/blog/tags/go"}],"readingTime":5.12,"hasTruncateMarker":true,"authors":[{"name":"Fiber Team","title":"Maintainers","url":"https://github.com/gofiber/fiber","imageURL":"https://github.com/gofiber.png","key":"fiber-team","page":null}],"frontMatter":{"slug":"fiber-v3-client-deep-dive","title":"New Client Deep Dive","authors":["fiber-team"],"tags":["fiber","v3","client","http","go"],"description":"How to use the new Fiber client package for reliable service-to-service communication."},"unlisted":false,"prevItem":{"title":"Binding in Practice","permalink":"/blog/fiber-v3-binding-in-practice"},"nextItem":{"title":"Deliver a SPA with Fiber v3","permalink":"/blog/spa-delivery-with-fiber-v3"}},"content":"In many backend teams, outbound HTTP calls are still treated like helper code. They live in random utility functions, each call has slightly different timeout behavior, and when incidents happen no one is fully sure which upstream policy is actually active.\\n\\nThat works while a service has two dependencies. It starts to hurt when a service has ten. Timeout drift, inconsistent retry behavior, missing correlation headers, and ad-hoc error mapping become real operational problems. When your on-call engineer cannot tell which upstream policy is in effect during an incident, the outbound client is the root cause even when the upstream itself is fine.\\n\\nThe v3 client package addresses this by treating outbound HTTP as a first-class concern. You define client behavior once, override it where needed, and keep request policy visible in one place.\\n\\n\x3c!-- truncate --\x3e\\n\\n## How Outbound Calls Looked in v2-era Code\\n\\nMost v2 services used `net/http` or `fasthttp` directly for outbound requests. The typical pattern was scattered one-off configurations:\\n\\n```go\\n// v2-era: ad-hoc outbound calls\\nfunc fetchUser(id string) (*User, error) {\\n    req, _ := http.NewRequest(\\"GET\\", \\"https://users.internal/users/\\"+id, nil)\\n    req.Header.Set(\\"Authorization\\", \\"Bearer \\"+token)\\n\\n    client := &http.Client{Timeout: 2 * time.Second}\\n    resp, err := client.Do(req)\\n    // ... error handling, body parsing, cleanup\\n}\\n```\\n\\nEach function created its own client, set its own timeout, and handled its own headers. When the team wanted to add tracing or change the timeout, they had to find and update every call site. Policy drift was inevitable.\\n\\n## Start with a Client Factory\\n\\nThe v3 client package encourages creating long-lived, configured client instances. A factory function makes this pattern explicit:\\n\\n```go\\nimport (\\n    \\"time\\"\\n    \\"github.com/gofiber/fiber/v3/client\\"\\n)\\n\\nfunc NewUsersClient() *client.Client {\\n    return client.New().\\n        SetBaseURL(\\"https://users.internal\\").\\n        SetTimeout(1500 * time.Millisecond).\\n        SetHeader(\\"X-Caller-Service\\", \\"billing-api\\")\\n}\\n```\\n\\nThis is simple, but it changes daily engineering behavior. New endpoints stop reinventing outbound setup and instead depend on a known client contract. Timeout, base URL, and default headers are defined once and shared across all calls through this client.\\n\\n## Per-Request Overrides\\n\\nWhen a specific call needs different behavior, overrides are explicit and local:\\n\\n```go\\nfunc FetchTenant(cli *client.Client, tenantID, reqID string) (*client.Response, error) {\\n    return cli.Get(\\"/tenants/:id\\", client.Config{\\n        PathParam: map[string]string{\\"id\\": tenantID},\\n        Header:    map[string]string{\\"X-Request-ID\\": reqID},\\n        Timeout:   600 * time.Millisecond,\\n    })\\n}\\n```\\n\\nThe `Config` struct supports headers, path parameters, query parameters, cookies, body, form data, file uploads, context propagation, max redirects, and timeout \u2014 all per request. A good review question here is: \\"Why is this override different from the default?\\" If the answer is clear, the override belongs here. If not, move the policy back into shared defaults.\\n\\n## Retry Configuration\\n\\nFor transient failures, the client supports retry policies:\\n\\n```go\\ncli := client.New().\\n    SetBaseURL(\\"https://api.internal\\").\\n    SetRetryConfig(&client.RetryConfig{\\n        MaxRetryCount:   3,\\n        InitialInterval: 100 * time.Millisecond,\\n    })\\n```\\n\\nRetries apply to the configured client and can be tuned per upstream. This is especially useful for internal service calls where transient network errors are expected during rolling deployments.\\n\\n## Proxy Support\\n\\nIf your outbound calls need to go through a proxy (corporate environments, egress gateways), the client supports proxy configuration:\\n\\n```go\\ncli := client.New()\\ncli.SetProxyURL(\\"http://proxy.internal:8080\\")\\n```\\n\\nThis applies to all requests through the client instance. Combined with base URL and headers, you can model complex network topologies without per-request proxy logic.\\n\\n## Cookie Jar for Session Continuity\\n\\nA lot of teams first see cookie jar support and think it is only for browsers. In practice, it is useful for integration flows and internal tools that still rely on session-style auth.\\n\\n```go\\njar := client.AcquireCookieJar()\\ndefer client.ReleaseCookieJar(jar)\\n\\ncli := client.New().\\n    SetBaseURL(\\"https://auth.internal\\").\\n    SetCookieJar(jar)\\n\\n_, err := cli.Post(\\"/login\\", client.Config{\\n    FormData: map[string]string{\\n        \\"username\\": \\"john\\",\\n        \\"password\\": \\"doe\\",\\n    },\\n})\\nif err != nil {\\n    return err\\n}\\n\\n// Session cookie is automatically stored and sent with subsequent requests\\nprofileResp, err := cli.Get(\\"/me\\")\\nif err != nil {\\n    return err\\n}\\nfmt.Println(string(profileResp.Body()))\\n```\\n\\nThis is especially practical in end-to-end tests where you want session continuity without custom cookie plumbing, and in internal tools that interact with legacy session-based services.\\n\\n## Request and Response Hooks\\n\\nIn mature systems, outbound clients need observability. The v3 client makes this straightforward with request and response hooks:\\n\\n```go\\ncli.AddRequestHook(func(c *client.Client, req *client.Request) error {\\n    req.SetHeader(\\"X-Trace-Source\\", \\"fiber-client\\")\\n    return nil\\n})\\n\\ncli.AddResponseHook(func(c *client.Client, resp *client.Response, req *client.Request) error {\\n    log.Printf(\\"upstream=%s status=%d\\",\\n        req.URL(),\\n        resp.StatusCode(),\\n    )\\n    return nil\\n})\\n```\\n\\nRequest hooks run before every outbound call. Use them for tracing headers, authentication token injection, and request logging. Response hooks run after every response. Use them for metrics collection, error classification, and response logging.\\n\\nThis is the right place for cross-cutting concerns. It keeps handler code focused on business behavior and ensures observability is consistent across all calls through the client.\\n\\n## Debug Mode\\n\\nDuring development, you can enable debug mode to see full request and response details:\\n\\n```go\\ncli := client.New().Debug()\\n```\\n\\nThis logs request and response details for every call through the client. Disable it in production with `cli.DisableDebug()`. It is a simple feature, but it saves significant time when debugging upstream integration issues.\\n\\n## A Handler Example with Error Mapping\\n\\nHere is a handler that calls an upstream service and maps errors consistently:\\n\\n```go\\napp.Get(\\"/billing/:id\\", func(c fiber.Ctx) error {\\n    resp, err := billingClient.Get(\\"/invoices/:id\\", client.Config{\\n        PathParam: map[string]string{\\"id\\": c.Params(\\"id\\")},\\n        Header: map[string]string{\\n            \\"X-Request-ID\\": c.Get(\\"X-Request-ID\\"),\\n        },\\n    })\\n    if err != nil {\\n        return c.Status(fiber.StatusBadGateway).JSON(fiber.Map{\\n            \\"error\\": \\"upstream unavailable\\",\\n        })\\n    }\\n\\n    if resp.StatusCode() >= 500 {\\n        return c.Status(fiber.StatusBadGateway).JSON(fiber.Map{\\n            \\"error\\": \\"upstream failed\\",\\n        })\\n    }\\n\\n    return c.Status(resp.StatusCode()).Send(resp.Body())\\n})\\n```\\n\\nThe important part is not syntax. It is that upstream error semantics are explicit: connection failures return 502, upstream 5xx errors return 502 with a generic message, and everything else forwards the upstream status. This pattern prevents leaking upstream error details to clients.\\n\\n## Where to Introduce This First\\n\\nIf you want fast impact, migrate the noisiest dependency first. Usually that is the upstream that already causes timeout and retry tickets. Move only that path to a shared client layer and compare behavior over one week.\\n\\nYou will usually see better consistency in logs, easier debugging, and clearer ownership of outbound policy.\\n\\n## Internal References\\n\\n- [Client REST](/client/rest)\\n- [Client Examples](/client/examples)\\n- [What\'s New](/whats_new)"},{"id":"spa-delivery-with-fiber-v3","metadata":{"permalink":"/blog/spa-delivery-with-fiber-v3","editUrl":"https://github.com/gofiber/docs/tree/master/blog/2026-02-14-spa-delivery-with-fiber-v3.md","source":"@site/blog/2026-02-14-spa-delivery-with-fiber-v3.md","title":"Deliver a SPA with Fiber v3","description":"Serve SPA assets and handle client-side routes correctly with Fiber v3 fallback patterns.","date":"2026-02-14T00:00:00.000Z","tags":[{"inline":true,"label":"fiber","permalink":"/blog/tags/fiber"},{"inline":true,"label":"v3","permalink":"/blog/tags/v-3"},{"inline":true,"label":"spa","permalink":"/blog/tags/spa"},{"inline":true,"label":"react","permalink":"/blog/tags/react"},{"inline":true,"label":"routing","permalink":"/blog/tags/routing"},{"inline":true,"label":"static","permalink":"/blog/tags/static"},{"inline":true,"label":"go","permalink":"/blog/tags/go"}],"readingTime":4.54,"hasTruncateMarker":true,"authors":[{"name":"Fiber Team","title":"Maintainers","url":"https://github.com/gofiber/fiber","imageURL":"https://github.com/gofiber.png","key":"fiber-team","page":null}],"frontMatter":{"slug":"spa-delivery-with-fiber-v3","title":"Deliver a SPA with Fiber v3","authors":["fiber-team"],"tags":["fiber","v3","spa","react","routing","static","go"],"description":"Serve SPA assets and handle client-side routes correctly with Fiber v3 fallback patterns."},"unlisted":false,"prevItem":{"title":"New Client Deep Dive","permalink":"/blog/fiber-v3-client-deep-dive"},"nextItem":{"title":"Serve Static Files with Fiber v3","permalink":"/blog/static-server-with-fiber-v3"}},"content":"Most SPA delivery issues are not frontend bugs. They are server routing mismatches.\\n\\nThe homepage works, client-side navigation works, and then someone refreshes a deep link in production and gets a server-side `404`. It happens all the time because backend and frontend route ownership was never made explicit.\\n\\nFiber v3 makes this easy to solve once you set the pattern correctly.\\n\\n\x3c!-- truncate --\x3e\\n\\n## What Changed from v2\\n\\nIn v2, static file serving used the built-in `app.Static()` method:\\n\\n```go\\n// v2: built-in static method\\napp.Static(\\"/\\", \\"./web/build\\")\\n```\\n\\nIn v3, `app.Static()` is removed. You use the static middleware instead, which gives you more control over fallback behavior, caching, and 404 handling. The `Filesystem` middleware has also been removed \u2014 the static middleware covers both cases.\\n\\n```go\\n// v3: static middleware\\nimport \\"github.com/gofiber/fiber/v3/middleware/static\\"\\n\\napp.Get(\\"/*\\", static.New(\\"./web/build\\"))\\n```\\n\\nFor SPA delivery, this change is actually an improvement because the middleware configuration gives you explicit control over how missing files are handled \u2014 which is exactly what SPA fallback routing needs.\\n\\n## The Core Idea: Two Route Behaviors, One Service\\n\\nServing an SPA correctly means your backend must do two different things:\\n\\n1. serve real static assets when the file exists (CSS, JS, images)\\n2. return `index.html` for app routes that the client router owns\\n\\nThe `react-router` recipe demonstrates this clearly:\\n\\n```go\\napp := fiber.New()\\n\\n// Static assets\\napp.Get(\\"/*\\", static.New(\\"./web/build\\"))\\n\\n// SPA fallback \u2014 serves index.html for any route the static middleware does not match\\napp.Get(\\"*\\", static.New(\\"./web/build/index.html\\"))\\n\\nlog.Fatal(app.Listen(\\":8080\\"))\\n```\\n\\nIf your app is mounted under a subpath (for example `/web`), server paths and frontend router basename must match.\\n\\n## How Request Resolution Works\\n\\n```mermaid\\nflowchart LR\\n    A[\\"Browser requests URL\\"] --\x3e B{\\"Is this a real asset file?\\"}\\n    B -- yes --\x3e C[\\"Serve static asset\\"]\\n    B -- no --\x3e D[\\"Serve index.html\\"]\\n    D --\x3e E[\\"Client router renders target page\\"]\\n```\\n\\nThis is the mental model you want every team member to share. It prevents endless \\"is this a frontend issue or backend issue?\\" loops.\\n\\n## Coexisting with API Routes\\n\\nMost SPAs need API endpoints alongside the static frontend. The key is route ordering: register API routes before the SPA fallback so they take priority:\\n\\n```go\\napp := fiber.New()\\n\\n// API routes \u2014 registered first, take priority\\napi := app.Group(\\"/api\\")\\napi.Get(\\"/users\\", listUsers)\\napi.Post(\\"/users\\", createUser)\\napi.Get(\\"/health\\", healthCheck)\\n\\n// Static assets\\napp.Get(\\"/*\\", static.New(\\"./web/build\\"))\\n\\n// SPA fallback \u2014 catches everything else\\napp.Get(\\"*\\", static.New(\\"./web/build/index.html\\"))\\n```\\n\\nWith this ordering, a request to `/api/users` hits the API handler. A request to `/dashboard` falls through to the static middleware, finds no file, and then the fallback serves `index.html` so the client router can render the dashboard page.\\n\\nIf you use v3\'s stricter middleware prefix matching, `/api` routes will not accidentally match `/api-docs` or `/api-key-generator` paths. This prevents a common source of routing confusion in apps that have both API endpoints and pages with similar prefixes.\\n\\n## Run Locally\\n\\nUse the recipe workflow. Docker is usually the easiest path for consistent setup.\\n\\n```bash\\ngit clone https://github.com/gofiber/recipes.git\\ncd recipes/react-router\\n\\n# Option A: Docker (recommended by recipe)\\ndocker build . -t react-router:latest\\ndocker run -d -p 8080:8080 react-router:latest\\n\\n# Option B: Manual toolchain\\ncd web && yarn install && yarn build\\ncd ..\\ngo run ./cmd/react-router/main.go\\n```\\n\\n## Smoke Tests That Catch Real Breakage\\n\\n```bash\\n# Root should return index.html\\ncurl -i http://localhost:8080/\\n\\n# Known client route should also return index.html (not 404)\\ncurl -i http://localhost:8080/react\\n\\n# Unknown route should return index.html (SPA handles 404 display)\\ncurl -i http://localhost:8080/does-not-exist\\n\\n# API route should return JSON (if you added API routes)\\ncurl -i http://localhost:8080/api/health\\n```\\n\\nThen do the browser check that matters most:\\n\\n1. open a deep route directly (e.g., `http://localhost:8080/react`)\\n2. refresh the page\\n3. confirm the app still loads instead of returning server `404`\\n\\nThis is the test that catches the most real-world SPA delivery bugs. If refresh works on deep routes, your fallback is set up correctly.\\n\\n## What Usually Breaks in Teams\\n\\nThe first issue is catch-all fallback placement. If it is too early in the chain, it can hide real static files and API routes. Always register specific routes before wildcards.\\n\\nThe second is basename mismatch. If the frontend router expects `/web` and the backend serves from `/`, behavior will look random even though both sides \\"work\\" separately. This is especially common when moving between environments with different base paths (local dev vs. staging vs. production with a reverse proxy prefix).\\n\\nThe third is cache confusion. If `index.html` is cached too aggressively, users keep loading old route manifests after deploy. The fix is to set no-cache or very short `MaxAge` for HTML files while caching versioned assets (JS, CSS with content hashes) aggressively:\\n\\n```go\\n// Don\'t cache the HTML shell\\napp.Get(\\"/\\", static.New(\\"./web/build/index.html\\", static.Config{\\n    MaxAge: 0,\\n}))\\n\\n// Cache versioned assets long-term\\napp.Get(\\"/static/*\\", static.New(\\"./web/build/static\\", static.Config{\\n    MaxAge: 31536000, // 1 year\\n}))\\n```\\n\\n## Recipe and Next Step\\n\\n- Primary reference: [gofiber/recipes/react-router](https://github.com/gofiber/recipes/tree/master/react-router)\\n- Alternate reference: [gofiber/recipes/spa](https://github.com/gofiber/recipes/tree/master/spa)\\n- Related: [Serve Static Files with Fiber v3](/blog/static-server-with-fiber-v3)\\n\\nA good next step is to make cache policy explicit per file type and document route ownership between backend and frontend in your service README. If your deployment includes a reverse proxy, test the SPA fallback through the full proxy chain, not just locally."},{"id":"static-server-with-fiber-v3","metadata":{"permalink":"/blog/static-server-with-fiber-v3","editUrl":"https://github.com/gofiber/docs/tree/master/blog/2026-02-13-static-server-with-fiber-v3.md","source":"@site/blog/2026-02-13-static-server-with-fiber-v3.md","title":"Serve Static Files with Fiber v3","description":"A practical guide to serving static assets in Fiber v3 with correct routing and caching choices.","date":"2026-02-13T00:00:00.000Z","tags":[{"inline":true,"label":"fiber","permalink":"/blog/tags/fiber"},{"inline":true,"label":"v3","permalink":"/blog/tags/v-3"},{"inline":true,"label":"static","permalink":"/blog/tags/static"},{"inline":true,"label":"middleware","permalink":"/blog/tags/middleware"},{"inline":true,"label":"go","permalink":"/blog/tags/go"}],"readingTime":4.01,"hasTruncateMarker":true,"authors":[{"name":"Fiber Team","title":"Maintainers","url":"https://github.com/gofiber/fiber","imageURL":"https://github.com/gofiber.png","key":"fiber-team","page":null}],"frontMatter":{"slug":"static-server-with-fiber-v3","title":"Serve Static Files with Fiber v3","authors":["fiber-team"],"tags":["fiber","v3","static","middleware","go"],"description":"A practical guide to serving static assets in Fiber v3 with correct routing and caching choices."},"unlisted":false,"prevItem":{"title":"Deliver a SPA with Fiber v3","permalink":"/blog/spa-delivery-with-fiber-v3"},"nextItem":{"title":"Build a CRUD API with Fiber","permalink":"/blog/build-a-crud-app-with-fiber"}},"content":"Static delivery is one of those topics that seems boring until it breaks.\\n\\nA frontend deploy goes out, cache headers are wrong, the browser serves stale files, and suddenly support channels fill with \\"I still see the old UI\\" messages. Or worse: your container image uses a different working directory than local dev, and assets that worked locally return 404 in production.\\n\\nFiber v3 gives you a very capable static middleware surface. The trick is not only to use it, but to use it with clear policy.\\n\\n\x3c!-- truncate --\x3e\\n\\n## What Changed from v2\\n\\nIn v2, static file serving was a method on the app itself:\\n\\n```go\\n// v2: app.Static was a built-in method\\napp.Static(\\"/\\", \\"./public\\")\\n```\\n\\nIn v3, `app.Static()` has been removed. Static serving is now handled by the static middleware, which gives you more configuration options and a cleaner separation between routing and file serving:\\n\\n```go\\n// v3: static middleware imported separately\\nimport \\"github.com/gofiber/fiber/v3/middleware/static\\"\\n\\napp.Get(\\"/*\\", static.New(\\"./public\\"))\\n```\\n\\nThe `Filesystem` middleware has also been removed \u2014 the static middleware now covers both use cases. If your v2 code used `app.Static()` or the filesystem middleware, update to the static middleware as part of your migration.\\n\\n## Start Small, Then Add Rules Intentionally\\n\\nThe minimal setup from the recipe is short and useful:\\n\\n```go\\napp := fiber.New()\\napp.Get(\\"/*\\", static.New(\\"./files\\"))\\nlog.Fatal(app.Listen(\\":3000\\"))\\n```\\n\\nThis is enough for local demos and internal tooling. In production you usually need explicit decisions around browsing, cache duration, and missing-file behavior.\\n\\n## A Production-Leaning Static Policy\\n\\n```go\\napp.Get(\\"/*\\", static.New(\\"./files\\", static.Config{\\n    Browse:        false,\\n    MaxAge:        3600,\\n    CacheDuration: 10 * time.Second,\\n    NotFoundHandler: func(c fiber.Ctx) error {\\n        return c.Status(fiber.StatusNotFound).JSON(fiber.Map{\\n            \\"error\\": \\"asset not found\\",\\n            \\"path\\":  c.Path(),\\n        })\\n    },\\n}))\\n```\\n\\nWhy these settings matter:\\n\\n- `Browse: false` avoids accidental directory listings that can expose internal file structure\\n- `MaxAge` defines client-side cache behavior via `Cache-Control` (start conservative and tune based on asset types)\\n- `CacheDuration` controls how long the middleware keeps file data in memory before re-reading from disk\\n- `NotFoundHandler` gives you predictable 404 responses instead of opaque defaults\\n\\n## Serving from Embedded Filesystems\\n\\nFor single-binary deployments, Go\'s `embed.FS` is a practical choice. The static middleware supports any `fs.FS` implementation through the `FS` config field:\\n\\n```go\\n//go:embed public/*\\nvar embedFS embed.FS\\n\\nsub, _ := fs.Sub(embedFS, \\"public\\")\\napp.Get(\\"/*\\", static.New(\\"\\", static.Config{\\n    FS: sub,\\n}))\\n```\\n\\nThe `fs.Sub` call strips the `public/` prefix from the embedded filesystem, so the middleware finds files at their expected paths. Without it, a request for `/index.html` would look for `public/index.html` inside the FS and fail.\\n\\nThis embeds your static assets directly into the compiled binary. No separate file copy step in your Dockerfile, no working directory confusion. The binary contains everything it needs.\\n\\nYou can also use `os.DirFS` when you need a sandboxed directory without the `embed` directive:\\n\\n```go\\napp.Get(\\"/files*\\", static.New(\\"\\", static.Config{\\n    FS:     os.DirFS(\\"files\\"),\\n    Browse: true,\\n}))\\n```\\n\\n## Request Resolution, Visualized\\n\\n```mermaid\\nflowchart TD\\n    A[\\"Incoming request\\"] --\x3e B[\\"Wildcard route /*\\"]\\n    B --\x3e C[\\"static middleware\\"]\\n    C --\x3e D{\\"File exists?\\"}\\n    D -- yes --\x3e E[\\"Serve file + cache headers\\"]\\n    D -- no --\x3e F[\\"NotFoundHandler or default 404\\"]\\n```\\n\\nThe important architecture point: route order and route scope matter. If your app also exposes APIs, make sure static wildcard routes do not capture API paths unintentionally. Register API routes before the static wildcard, or scope the wildcard to a specific prefix:\\n\\n```go\\n// API routes first\\napi := app.Group(\\"/api\\")\\napi.Get(\\"/users\\", listUsers)\\n\\n// Static wildcard after API routes\\napp.Get(\\"/*\\", static.New(\\"./public\\"))\\n```\\n\\n## Run Locally\\n\\n```bash\\ngit clone https://github.com/gofiber/recipes.git\\ncd recipes/file-server\\ngo run main.go\\n```\\n\\nThen verify one text file, one binary, and one missing path.\\n\\n```bash\\ncurl -i http://localhost:3000/hello.txt\\ncurl -I http://localhost:3000/gopher.gif\\ncurl -i http://localhost:3000/missing.txt\\n```\\n\\n## Real-World Notes That Save Time Later\\n\\nThe most common static-serving bug is path confusion between local and deployed environments. Container working directories are often different from local shells, so be explicit about file roots in your image/runtime layout. Using `embed.FS` eliminates this class of bugs entirely.\\n\\nThe second most common bug is bad cache strategy. HTML shells and immutable hashed assets usually need different cache behavior. Treating them the same often creates either stale UI or unnecessary bandwidth usage. A practical split: no-cache or short `MaxAge` for HTML files, long `MaxAge` (1 year) for versioned JS/CSS with content hashes in filenames.\\n\\nThe third one is broad wildcards too early in the chain. Keep API routes explicit and test for route collisions before release. v3\'s stricter middleware prefix matching helps here \u2014 `/api` middleware no longer accidentally matches `/api-docs`.\\n\\n## Recipe and Next Step\\n\\n- Primary reference: [gofiber/recipes/file-server](https://github.com/gofiber/recipes/tree/master/file-server)\\n- Static middleware docs: [Static Middleware](/middleware/static)\\n\\nA practical next step is to split cache policy by asset class: short cache for HTML, longer cache for versioned JS/CSS, and clear invalidation strategy during deploys."},{"id":"build-a-crud-app-with-fiber","metadata":{"permalink":"/blog/build-a-crud-app-with-fiber","editUrl":"https://github.com/gofiber/docs/tree/master/blog/2026-02-12-build-a-crud-app-with-fiber.md","source":"@site/blog/2026-02-12-build-a-crud-app-with-fiber.md","title":"Build a CRUD API with Fiber","description":"Build a practical CRUD API in Fiber v3 and keep the request flow understandable as it grows.","date":"2026-02-12T00:00:00.000Z","tags":[{"inline":true,"label":"fiber","permalink":"/blog/tags/fiber"},{"inline":true,"label":"v3","permalink":"/blog/tags/v-3"},{"inline":true,"label":"crud","permalink":"/blog/tags/crud"},{"inline":true,"label":"gorm","permalink":"/blog/tags/gorm"},{"inline":true,"label":"postgres","permalink":"/blog/tags/postgres"},{"inline":true,"label":"go","permalink":"/blog/tags/go"}],"readingTime":4.62,"hasTruncateMarker":true,"authors":[{"name":"Fiber Team","title":"Maintainers","url":"https://github.com/gofiber/fiber","imageURL":"https://github.com/gofiber.png","key":"fiber-team","page":null}],"frontMatter":{"slug":"build-a-crud-app-with-fiber","title":"Build a CRUD API with Fiber","authors":["fiber-team"],"tags":["fiber","v3","crud","gorm","postgres","go"],"description":"Build a practical CRUD API in Fiber v3 and keep the request flow understandable as it grows."},"unlisted":false,"prevItem":{"title":"Serve Static Files with Fiber v3","permalink":"/blog/static-server-with-fiber-v3"},"nextItem":{"title":"What\'s New in Fiber v3","permalink":"/blog/whats-new-in-fiber-v3"}},"content":"CRUD APIs are often where a backend project either becomes maintainable or becomes expensive.\\n\\nAt first, everything feels easy: a quick route, a quick DB call, done. Three months later, handlers parse requests in different ways, errors are inconsistent, and every change takes twice as long as expected.\\n\\nThis post is about avoiding that path from the start.\\n\\nWe\'ll use Fiber v3 with the `gorm-postgres` recipe, but the real goal is not just to \\"get CRUD working.\\" The goal is to set up a structure your team can still understand when the API grows.\\n\\n\x3c!-- truncate --\x3e\\n\\n## What We Are Building\\n\\nA simple books API with five operations:\\n\\n- create a book\\n- list all books\\n- query by title\\n- update a book\\n- delete a book\\n\\nNothing here is technically complex. That is exactly why it is a good example: if the simple path is clean, the complex path gets easier later.\\n\\n## Why Route Structure Matters More Than People Think\\n\\nIn early APIs, teams usually focus on handler internals and ignore route shape. Then versioning starts, clients depend on edge-case behavior, and cleanup gets painful.\\n\\nThe recipe keeps route registration explicit in one place:\\n\\n```go\\nfunc setUpRoutes(app *fiber.App) {\\n    app.Get(\\"/hello\\", routes.Hello)\\n    app.Get(\\"/allbooks\\", routes.AllBooks)\\n    app.Post(\\"/addbook\\", routes.AddBook)\\n    app.Post(\\"/book\\", routes.Book)\\n    app.Put(\\"/update\\", routes.Update)\\n    app.Delete(\\"/delete\\", routes.Delete)\\n}\\n```\\n\\nThat explicit list gives you two advantages immediately:\\n\\n1. onboarding gets faster because route intent is visible in one file\\n2. versioning is straightforward later (`/api/v1`, `/api/v2`) because your boundary is already clear\\n\\nA note on route naming: the recipe uses action-based paths like `/addbook` and `/allbooks`, which works well for learning. In production, RESTful resource-based paths (`GET /books`, `POST /books`, `GET /books/:id`, `PUT /books/:id`, `DELETE /books/:id`) are usually a better choice because they map naturally to HTTP semantics and make API documentation cleaner. The migration from one style to the other is straightforward when routes are centralized like this.\\n\\n## Input Handling: What Changed from v2\\n\\nIn v2, body parsing used `c.BodyParser()`, query parameters used individual `c.Query()` calls, and path parameters used `c.ParamsInt()`. Each had different error behavior and conventions.\\n\\nv3 unifies all of this under `c.Bind()`. The recipe handler shows the pattern:\\n\\n```go\\nfunc AddBook(c fiber.Ctx) error {\\n    book := new(models.Book)\\n\\n    if err := c.Bind().Body(book); err != nil {\\n        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\\"error\\": err.Error()})\\n    }\\n\\n    if result := database.DB.Db.Create(book); result.Error != nil {\\n        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{\\n            \\"error\\": \\"failed to create book\\",\\n            \\"code\\":  \\"CREATE_FAILED\\",\\n        })\\n    }\\n    return c.Status(fiber.StatusCreated).JSON(book)\\n}\\n```\\n\\nThis may look trivial, but the consistency matters. Every handler follows the same shape: bind input, check for errors, run logic, return response. When your team agrees on this pattern, code reviews get shorter and parsing bugs become rare.\\n\\nIf you need validation beyond what struct tags provide, Fiber v3 supports built-in validation through the `StructValidator` config. You configure it once at app level and every `Bind()` call automatically validates:\\n\\n```go\\ntype CreateBook struct {\\n    Title  string `json:\\"title\\" validate:\\"required\\"`\\n    Author string `json:\\"author\\" validate:\\"required\\"`\\n}\\n```\\n\\nSee the [Binding in Practice](/blog/fiber-v3-binding-in-practice) post for the full validation setup.\\n\\n## What Actually Happens in a CRUD Request\\n\\n```mermaid\\nflowchart LR\\n    A[\\"Client sends JSON\\"] --\x3e B[\\"Fiber matches route\\"]\\n    B --\x3e C[\\"c.Bind().Body parses payload\\"]\\n    C --\x3e D{\\"Payload valid?\\"}\\n    D -- no --\x3e E[\\"Return 400\\"]\\n    D -- yes --\x3e F[\\"Run GORM operation\\"]\\n    F --\x3e G[\\"PostgreSQL\\"]\\n    G --\x3e H[\\"Return JSON response\\"]\\n```\\n\\nThe key design choice is where errors are handled. Do not push parse/validation errors too deep. If they are request-shape errors, fail early and return stable responses.\\n\\n## Run Locally\\n\\n```bash\\ngit clone https://github.com/gofiber/recipes.git\\ncd recipes/gorm-postgres\\ngo run app.go\\n```\\n\\nThe recipe expects local Postgres defaults. If your environment differs, adjust DSN settings in `database/database.go`.\\n\\n## Smoke Tests That Are Worth Running\\n\\n```bash\\n# Create\\ncurl -i -X POST http://localhost:3000/addbook \\\\\\n  -H \'Content-Type: application/json\' \\\\\\n  -d \'{\\"title\\":\\"Distributed Systems\\",\\"author\\":\\"Tanenbaum\\"}\'\\n\\n# Read all\\ncurl -i http://localhost:3000/allbooks\\n\\n# Read by title\\ncurl -i -X POST http://localhost:3000/book \\\\\\n  -H \'Content-Type: application/json\' \\\\\\n  -d \'{\\"title\\":\\"Distributed Systems\\"}\'\\n\\n# Update\\ncurl -i -X PUT http://localhost:3000/update \\\\\\n  -H \'Content-Type: application/json\' \\\\\\n  -d \'{\\"title\\":\\"Distributed Systems\\",\\"author\\":\\"A. Tanenbaum\\"}\'\\n\\n# Delete\\ncurl -i -X DELETE http://localhost:3000/delete \\\\\\n  -H \'Content-Type: application/json\' \\\\\\n  -d \'{\\"title\\":\\"Distributed Systems\\"}\'\\n```\\n\\nThese are not just demo commands. They are a minimum regression checklist for any CRUD service before merging route changes.\\n\\n## Practical Lessons Before You Ship This Pattern\\n\\nThe recipe updates and deletes by title. That is fine for learning, but in production you should usually move to immutable identifiers (numeric ID, UUID, ULID). Fiber v3 supports [custom route constraints](/blog/whats-new-in-fiber-v3#8-custom-route-constraints) that can validate identifier formats at the routing layer, so invalid IDs never reach your handler.\\n\\nAvoid sending raw database errors to clients. A stable error envelope makes frontend integration predictable and simplifies incident handling:\\n\\n```go\\n// consistent error response shape\\nreturn c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{\\n    \\"error\\": \\"failed to create book\\",\\n    \\"code\\":  \\"CREATE_FAILED\\",\\n})\\n```\\n\\nFinally, if you add auth/validation middleware later, keep the same flow discipline: bind input, validate, execute logic, map response. That consistency is what makes the codebase scale.\\n\\n## Recipe and Next Step\\n\\n- Primary reference: [gofiber/recipes/gorm-postgres](https://github.com/gofiber/recipes/tree/master/gorm-postgres)\\n\\nA strong next step is to add validation (see [Binding in Practice](/blog/fiber-v3-binding-in-practice)) and move routes under `/api/v1` with consistent response envelopes (`data`, `error`, `meta`). That gives you a cleaner base before feature count grows."},{"id":"whats-new-in-fiber-v3","metadata":{"permalink":"/blog/whats-new-in-fiber-v3","editUrl":"https://github.com/gofiber/docs/tree/master/blog/2026-02-11-whats-new-in-fiber-v3.md","source":"@site/blog/2026-02-11-whats-new-in-fiber-v3.md","title":"What\'s New in Fiber v3","description":"A practical, migration-first guide to Fiber v3 with examples you can apply in production.","date":"2026-02-11T00:00:00.000Z","tags":[{"inline":true,"label":"fiber","permalink":"/blog/tags/fiber"},{"inline":true,"label":"v3","permalink":"/blog/tags/v-3"},{"inline":true,"label":"migration","permalink":"/blog/tags/migration"},{"inline":true,"label":"go","permalink":"/blog/tags/go"}],"readingTime":8.45,"hasTruncateMarker":true,"authors":[{"name":"Fiber Team","title":"Maintainers","url":"https://github.com/gofiber/fiber","imageURL":"https://github.com/gofiber.png","key":"fiber-team","page":null}],"frontMatter":{"slug":"whats-new-in-fiber-v3","title":"What\'s New in Fiber v3","authors":["fiber-team"],"tags":["fiber","v3","migration","go"],"description":"A practical, migration-first guide to Fiber v3 with examples you can apply in production."},"unlisted":false,"prevItem":{"title":"Build a CRUD API with Fiber","permalink":"/blog/build-a-crud-app-with-fiber"},"nextItem":{"title":"Welcome to the Fiber Blog","permalink":"/blog/welcome-to-fiber-blog"}},"content":"When most teams read a \\"what\'s new\\" post, they are usually looking for one of two things.\\n\\nThe first is curiosity: what did the framework ship?\\nThe second is risk management: what do we need to change first, and what can wait until later?\\n\\nFor Fiber v3, the second question is the important one.\\n\\nThe release includes a lot of meaningful work, but a few parts have outsized impact in real services: request binding, lifecycle hooks, listen configuration, handler compatibility, context improvements, and the new extractors package.\\n\\nThis article is intentionally written for that reality. You should be able to read this, open one service in your codebase, and know exactly what to migrate first and why.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Before You Start: Go 1.25 and the Migration CLI\\n\\nFiber v3 requires **Go 1.25** or later. Update your toolchain before upgrading so the module `go` directive and standard library features align with the new minimum version.\\n\\nBefore you dive into manual refactors, use the migration helper that ships with the Fiber CLI. It can take care of a large part of repetitive upgrade work and gives you a cleaner baseline for the manual improvements described in this post.\\n\\n```bash\\ngo install github.com/gofiber/cli/fiber@latest\\nfiber migrate --to v3.0.0\\n```\\n\\nYou still need to review and test the result, but using the migrator first usually saves time and reduces mechanical errors.\\n\\n## Start with an Upgrade Strategy, Not a Feature Tour\\n\\nThe teams that struggle with migrations usually do one thing wrong: they migrate randomly.\\n\\nSomeone updates one handler. Someone else copies a new example into another package. A third person keeps old parsing logic because \\"it still works.\\" After two sprints, the codebase is half old, half new, and debugging gets harder.\\n\\nFiber v3 rewards the opposite approach:\\n\\n1. standardize request input first\\n2. standardize lifecycle behavior second\\n3. modernize client and boundary layers third\\n\\nIf you do that in order, you get consistency fast and avoid expensive refactors later.\\n\\n## 1) Unified Binding: The Single Biggest Migration Win\\n\\nOne of the most important v3 changes is the unified binding system. In v2, request parsing was split across `BodyParser`, `ParamsInt`, `QueryBool`, `CookieParser`, and individual `c.Query()` / `c.Get()` calls. Each method had its own behavior, and handlers ended up with inconsistent parsing styles.\\n\\nv3 replaces all of that with `c.Bind()`:\\n\\n```go\\ntype UserInput struct {\\n    ID      int    `uri:\\"id\\" json:\\"id\\" query:\\"id\\"`\\n    Name    string `json:\\"name\\" form:\\"name\\" query:\\"name\\"`\\n    Role    string `header:\\"X-Role\\"`\\n    Session string `cookie:\\"session_id\\"`\\n}\\n\\napp.Post(\\"/users/:id\\", func(c fiber.Ctx) error {\\n    in := new(UserInput)\\n\\n    if err := c.Bind().All(in); err != nil {\\n        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\\"error\\": err.Error()})\\n    }\\n\\n    return c.JSON(in)\\n})\\n```\\n\\n`Bind().All()` applies sources in a fixed precedence: URI params, body, query, headers, cookies. That removes ambiguity in mixed-source endpoints. There are also focused methods like `Bind().Body()`, `Bind().Query()`, `Bind().Header()`, `Bind().Cookie()`, and `Bind().URI()` when you only need one source.\\n\\nv3 binding also supports built-in validation, default values via `default:` tags, and custom binders for formats like YAML. Native CBOR and MsgPack support is included alongside JSON, XML, and form data.\\n\\nFor a deep dive, see [Binding in Practice](/blog/fiber-v3-binding-in-practice).\\n\\n## 2) Lifecycle Hooks: Deploy Confidence\\n\\nMost APIs are not just request handlers. They run workers, queues, cleanup logic, telemetry flushes, and startup checks. In v2, the main lifecycle hook was `OnShutdown`, but you could not distinguish \\"before the server stops accepting\\" from \\"after everything is drained.\\"\\n\\nv3 replaces `OnShutdown` with explicit pre/post phases and adds startup message customization:\\n\\n```go\\napp.Hooks().OnPreStartupMessage(func(sm *fiber.PreStartupMessageData) error {\\n    sm.BannerHeader = \\"MY-SERVICE \\" + sm.Version\\n    sm.AddInfo(\\"env\\", \\"Environment\\", os.Getenv(\\"APP_ENV\\"))\\n    return nil\\n})\\n\\napp.Hooks().OnPreShutdown(func() error {\\n    log.Println(\\"stopping workers\\")\\n    return stopConsumers()\\n})\\n\\napp.Hooks().OnPostShutdown(func(err error) error {\\n    log.Printf(\\"shutdown done, err=%v\\", err)\\n    return flushMetrics()\\n})\\n```\\n\\nv3 also adds registration-time hooks (`OnRoute`, `OnGroup`, `OnName`, `OnMount`) that fire when routes and sub-apps are registered, useful for building route registries and enforcing naming conventions.\\n\\nFor a deep dive, see [Hooks Guide for Clean Lifecycles](/blog/fiber-v3-hooks-guide).\\n\\n## 3) Listen: Cleaner Configuration\\n\\nFiber v3 tightens listen behavior and moves several config properties from `fiber.Config` to `ListenConfig`: `DisableStartupMessage`, `EnablePrefork`, `EnablePrintRoutes`, and `ListenerNetwork`.\\n\\nUnix sockets are a good example of the improvement. In v2 you had to manually delete old socket files, listen on a `unix` network, and chmod the socket in an `OnListen` hook. v3 handles it:\\n\\n```go\\napp := fiber.New()\\napp.Listen(\\"app.sock\\", fiber.ListenConfig{\\n    ListenerNetwork:    fiber.NetworkUnix,\\n    UnixSocketFileMode: 0770,\\n})\\n```\\n\\nv3 also adds native TLS AutoCert support with Let\'s Encrypt and ACME providers:\\n\\n```go\\ncertManager := &autocert.Manager{\\n    Prompt:     autocert.AcceptTOS,\\n    HostPolicy: autocert.HostWhitelist(\\"example.com\\"),\\n    Cache:      autocert.DirCache(\\"./certs\\"),\\n}\\n\\napp.Listen(\\":443\\", fiber.ListenConfig{\\n    AutoCertManager: certManager,\\n})\\n```\\n\\n## 4) Handler Compatibility: Migrate Without Rewriting\\n\\nIf your org has a large `net/http` or `fasthttp` surface, full rewrites are often unrealistic. Fiber v3 helps by accepting **17 different handler signatures** directly in the router, including native Fiber, `net/http`, `fasthttp`, and Express-style `Req`/`Res` callbacks:\\n\\n```go\\n// net/http handler \u2014 no adapter needed\\napp.Get(\\"/legacy\\", func(w http.ResponseWriter, r *http.Request) {\\n    w.WriteHeader(http.StatusOK)\\n    _, _ = w.Write([]byte(\\"legacy route\\"))\\n})\\n\\n// Express-style with next callback\\napp.Use(func(req fiber.Req, res fiber.Res, next func() error) error {\\n    req.Headers().Set(\\"X-Via\\", \\"compat\\")\\n    return next()\\n})\\n```\\n\\nThis enables route-by-route migration. You modernize high-value endpoints first while keeping legacy handlers operational.\\n\\nv3 also adds `RouteChain` for Express-style route declaration and automatically registers `HEAD` routes for every `GET` route.\\n\\nFor a deep dive, see [Handler Compatibility in the New Router](/blog/fiber-v3-adapter-pattern).\\n\\n## 5) Context Implements `context.Context`\\n\\n`fiber.Ctx` now satisfies Go\'s `context.Context` interface. This eliminates the v2 pattern of calling `c.UserContext()` to bridge between Fiber and the standard library:\\n\\n```go\\n// v2: manual bridging\\nctx := c.UserContext()\\nrows, err := db.QueryContext(ctx, \\"SELECT ...\\")\\n\\n// v3: pass Fiber context directly\\nrows, err := db.QueryContext(c, \\"SELECT ...\\")\\n```\\n\\nDeadline propagation, cancellation, and request-scoped values all work natively. Libraries that accept `context.Context` now get proper request lifecycle integration without boilerplate.\\n\\nv3 also adds many new context methods: `Drop()` for silent connection termination (DDoS mitigation), `End()` for immediate response flush, `SendEarlyHints()` for HTTP 103 preloading, `AutoFormat()` for content negotiation, `SendStreamWriter()` for SSE and streaming, and numerous inspection helpers like `IsJSON()`, `IsWebSocket()`, `HasBody()`, and `IsPreflight()`.\\n\\nFor a deep dive on context extensions, see [Custom Context in Practice](/blog/fiber-v3-custom-context).\\n\\n## 6) Generic Functions: Type-Safe Parameter Access\\n\\nv3 introduces generic helper functions that replace the old type-specific methods:\\n\\n```go\\n// v2: ParamsInt, QueryBool, QueryFloat \u2014 individual methods\\nid, _ := c.ParamsInt(\\"id\\")\\n\\n// v3: generic functions with type inference and defaults\\nid := fiber.Params[int](c, \\"id\\", 0)\\nage := fiber.Query[int](c, \\"age\\", 18)\\nagent := fiber.GetReqHeader[string](c, \\"User-Agent\\", \\"Unknown\\")\\n```\\n\\n`fiber.Locals[T]` provides type-safe local value storage, and `fiber.Convert[T]` handles custom conversions with fallback defaults.\\n\\n## 7) Extractors Package: Shared Middleware Policy\\n\\nThe new `extractors` package consolidates value extraction that was previously duplicated across middleware. Instead of each middleware implementing its own token/key lookup, they now share a common API:\\n\\n```go\\napp.Use(keyauth.New(keyauth.Config{\\n    Extractor: extractors.Chain(\\n        extractors.FromAuthHeader(\\"Bearer\\"),\\n        extractors.FromHeader(\\"X-API-Key\\"),\\n        extractors.FromCookie(\\"api_key\\"),\\n    ),\\n}))\\n```\\n\\n`FromAuthHeader` includes strict RFC 9110/7235 validation. The chain tries each source in order and returns the first success, making extraction policy explicit and auditable.\\n\\nFor a deep dive, see [Extractors Guide for Middleware](/blog/fiber-v3-extractors-guide).\\n\\n## 8) Custom Route Constraints\\n\\nInstead of validating every path parameter deep in handlers, you can move constraint logic to routing:\\n\\n```go\\ntype UlidConstraint struct{ fiber.CustomConstraint }\\n\\nfunc (*UlidConstraint) Name() string { return \\"ulid\\" }\\nfunc (*UlidConstraint) Execute(param string, _ ...string) bool {\\n    _, err := ulid.Parse(param)\\n    return err == nil\\n}\\n\\napp.RegisterCustomConstraint(&UlidConstraint{})\\napp.Get(\\"/users/:id<ulid>\\", func(c fiber.Ctx) error {\\n    return c.SendString(\\"valid id: \\" + c.Params(\\"id\\"))\\n})\\n```\\n\\nMalformed IDs never reach business logic. The route returns 404 before the handler runs.\\n\\n## 9) Cookie and RFC Improvements\\n\\nv3 makes several protocol improvements that reduce interoperability incidents:\\n\\n- **Auto-Secure for SameSite=None**: When you set `SameSite=None`, Fiber automatically adds `Secure=true` as required by RFC 6265bis and modern browsers\\n- **CHIPS support**: Partitioned cookies for third-party contexts via `Partitioned: true`\\n- **Non-ASCII filenames**: `Attachment` and `Download` use RFC 6266/8187 encoding\\n- **Default redirect status**: Changed from 302 to 303 for more consistent browser behavior\\n\\nFor a deep dive, see [RFC Conformance in Practice](/blog/fiber-v3-rfc-conformance).\\n\\n## 10) Storage, Client, and Middleware Updates\\n\\n**Storage**: All storage adapters now include `WithContext` methods (`GetWithContext`, `SetWithContext`, `DeleteWithContext`, `ResetWithContext`) for cancellation, timeout control, and request-scoped behavior.\\n\\n**Client**: The client package has been completely rebuilt with cookie jar support, request/response hooks, retry configuration, proxy support, and debug mode. See [New Client Deep Dive](/blog/fiber-v3-client-deep-dive).\\n\\n**Middleware changes worth noting**:\\n- `app.Static()` removed \u2014 use the [static middleware](/middleware/static) instead\\n- `Filesystem` middleware removed \u2014 static middleware covers both\\n- Middleware data now uses `FromContext()` functions (e.g., `requestid.FromContext(c)`) instead of string-based `c.Locals()` keys\\n- Cache middleware: RFC-compliant `Age` header, `MaxBytes` limit, non-cacheable status filtering\\n- Compression: zstd support added alongside gzip, deflate, and brotli\\n- CORS: fields changed from comma-separated strings to slices\\n- Healthcheck: simplified to single generic probe handler, no auto-registered endpoints\\n- BasicAuth: passwords must be hashed, authorizer receives `fiber.Ctx`\\n- Services: new feature for managing application dependencies (databases, caches) as first-class service objects\\n\\n## 11) Stricter Middleware Prefix Matching\\n\\nMiddleware prefix matching is now stricter: partial matches must end at a slash boundary or be an exact match. This prevents `/api` middleware from running on `/apiv1`:\\n\\n```go\\napp.Use(\\"/api\\", apiMiddleware)  // runs for /api and /api/... only\\n```\\n\\nMultiple prefixes are supported, and sub-apps mount with `app.Use()` instead of the removed `app.Mount()`.\\n\\n## Where to Practice These Changes\\n\\nFor the complete list of v3 changes, keep the official page open while migrating:\\n[What\'s New in Fiber v3](/whats_new)\\n\\n- CRUD + binding patterns: [gofiber/recipes/gorm-postgres](https://github.com/gofiber/recipes/tree/master/gorm-postgres)\\n- Static + middleware behavior: [gofiber/recipes/file-server](https://github.com/gofiber/recipes/tree/master/file-server)\\n- SPA fallback behavior: [gofiber/recipes/react-router](https://github.com/gofiber/recipes/tree/master/react-router)\\n- API docs integration: [gofiber/recipes/swagger](https://github.com/gofiber/recipes/tree/master/swagger)\\n\\nIf you only do one thing this week: pick one service, enforce a single binding style, and add lifecycle hooks around startup/shutdown. That alone delivers a measurable improvement in maintainability."},{"id":"welcome-to-fiber-blog","metadata":{"permalink":"/blog/welcome-to-fiber-blog","editUrl":"https://github.com/gofiber/docs/tree/master/blog/2026-02-10-welcome-to-fiber-blog.md","source":"@site/blog/2026-02-10-welcome-to-fiber-blog.md","title":"Welcome to the Fiber Blog","description":"This is the first post of the Docusaurus blog for Fiber docs.","date":"2026-02-10T00:00:00.000Z","tags":[{"inline":true,"label":"fiber","permalink":"/blog/tags/fiber"},{"inline":true,"label":"news","permalink":"/blog/tags/news"}],"readingTime":0.12,"hasTruncateMarker":true,"authors":[{"name":"Fiber Team","title":"Maintainers","url":"https://github.com/gofiber/fiber","imageURL":"https://github.com/gofiber.png","key":"fiber-team","page":null}],"frontMatter":{"slug":"welcome-to-fiber-blog","title":"Welcome to the Fiber Blog","authors":["fiber-team"],"tags":["fiber","news"]},"unlisted":false,"prevItem":{"title":"What\'s New in Fiber v3","permalink":"/blog/whats-new-in-fiber-v3"}},"content":"This is the first post of the Docusaurus blog for Fiber docs.\\n\\n\x3c!-- truncate --\x3e\\n\\nUse this space for release notes, migration guides, and ecosystem updates."}]}}')}}]);