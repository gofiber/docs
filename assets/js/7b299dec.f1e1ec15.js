"use strict";(self.webpackChunkfiber_docs=self.webpackChunkfiber_docs||[]).push([["40465"],{48802:function(e,n,t){t.r(n),t.d(n,{frontMatter:()=>a,toc:()=>d,default:()=>h,metadata:()=>i,assets:()=>l,contentTitle:()=>o});var i=JSON.parse('{"id":"extra/internal","title":"\u{1F3D7}\uFE0F Internal Architecture","description":"Learn about the internal architecture of Fiber, including the overall structure, request handling flow, routing, and path parsing.","source":"@site/docs/core/extra/internal.md","sourceDirName":"extra","slug":"/extra/internal","permalink":"/next/extra/internal","draft":false,"unlisted":false,"editUrl":"https://github.com/gofiber/fiber/edit/main/docs/extra/internal.md","tags":[],"version":"current","lastUpdatedAt":1762030608000,"sidebarPosition":3,"frontMatter":{"title":"\u{1F3D7}\uFE0F Internal Architecture","description":"Learn about the internal architecture of Fiber, including the overall structure, request handling flow, routing, and path parsing.","sidebar_position":3},"sidebar":"left_sidebar","previous":{"title":"\u{1F4CA} Benchmarks","permalink":"/next/extra/benchmarks"},"next":{"title":"\u{1F4DA} Learning Resources","permalink":"/next/extra/learning-resources"}}'),r=t(74848),s=t(84429);let a={title:"\u{1F3D7}\uFE0F Internal Architecture",description:"Learn about the internal architecture of Fiber, including the overall structure, request handling flow, routing, and path parsing.",sidebar_position:3},o,l={},d=[{value:"Overall Architecture",id:"overall-architecture",level:2},{value:"Explanation",id:"explanation",level:3},{value:"Request Processing Flow",id:"request-processing-flow",level:2},{value:"Additional Note",id:"additional-note",level:3},{value:"Routing &amp; Path Parsing",id:"routing--path-parsing",level:2},{value:"Explanation",id:"explanation-1",level:3},{value:"Route Matching and Parameter Extraction",id:"route-matching-and-parameter-extraction",level:2},{value:"Insight",id:"insight",level:3},{value:"Middleware Chain Execution",id:"middleware-chain-execution",level:2},{value:"Explanation",id:"explanation-2",level:3},{value:"Observations",id:"observations",level:3},{value:"Sub-Application Mounting &amp; Grouping",id:"sub-application-mounting--grouping",level:2},{value:"Impact",id:"impact",level:3},{value:"Route Tree Building",id:"route-tree-building",level:2},{value:"Explanation",id:"explanation-3",level:3},{value:"Context Lifecycle Management",id:"context-lifecycle-management",level:2},{value:"Key Benefit",id:"key-benefit",level:3},{value:"Preforking Mechanism",id:"preforking-mechanism",level:2},{value:"Explanation",id:"explanation-4",level:3},{value:"Detailed Preforking Workflow",id:"detailed-preforking-workflow",level:3},{value:"Explanation",id:"explanation-5",level:4},{value:"Redirection &amp; Flash Messages",id:"redirection--flash-messages",level:2},{value:"Explanation",id:"explanation-6",level:3},{value:"Flash Message Handling in Redirection",id:"flash-message-handling-in-redirection",level:3},{value:"Explanation",id:"explanation-7",level:4},{value:"Hooks, Error Handling &amp; Context Lifecycle",id:"hooks-error-handling--context-lifecycle",level:2},{value:"Hooks",id:"hooks",level:3},{value:"Explanation",id:"explanation-8",level:4},{value:"Error Handling &amp; Context Lifecycle",id:"error-handling--context-lifecycle",level:3},{value:"Explanation",id:"explanation-9",level:4}];function c(e){let n={code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",mermaid:"mermaid",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"overall-architecture",children:"Overall Architecture"}),"\n",(0,r.jsxs)(n.p,{children:["At the heart of Fiber is the ",(0,r.jsx)(n.strong,{children:"App"})," struct. It is responsible for configuring the server, managing a pool of Contexts (either our default implementation, ",(0,r.jsx)(n.strong,{children:"DefaultCtx"}),", or a user\u2011supplied ",(0,r.jsx)(n.strong,{children:"CustomCtx"}),"), and holding the router stack with all registered routes and groups. In addition, the App contains mount fields to support sub\u2011applications and hooks that allow developers to run custom code at key stages (e.g. when registering routes or starting the server)."]}),"\n",(0,r.jsx)(n.mermaid,{value:'flowchart TD\n    A[App]\n    B["Configuration (Config)"]\n    C[Context Pool]\n    D["DefaultCtx \\/ CustomCtx"]\n    E[Router Stack]\n    F["Groups & Routes"]\n    G["MountFields (Sub\u2011Apps)"]\n    H[Hooks]\n\n    A --\x3e B\n    A --\x3e C\n    C --\x3e D\n    A --\x3e E\n    E --\x3e F\n    A --\x3e G\n    A --\x3e H'}),"\n",(0,r.jsx)(n.h3,{id:"explanation",children:"Explanation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"App: The central object that bootstraps and runs the Fiber server."}),"\n",(0,r.jsx)(n.li,{children:"Configuration (Config): Contains settings for body limits, timeouts, TLS options, routing behavior (e.g. case\u2011sensitivity, strict routing), and more."}),"\n",(0,r.jsx)(n.li,{children:"Context Pool: A synchronized pool from which Contexts are acquired per request. This design minimizes allocations by recycling DefaultCtx (or CustomCtx) instances."}),"\n",(0,r.jsx)(n.li,{children:"Router Stack: Organizes all registered routes. It is later processed into a tree structure for fast route\u2011matching."}),"\n",(0,r.jsx)(n.li,{children:"MountFields: Support for mounting sub\u2011applications so that large APIs can be segmented into independent routers."}),"\n",(0,r.jsx)(n.li,{children:"Hooks: Allow for custom behavior at critical points (e.g., on route registration, route naming, on listen, on shutdown, etc.)."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"request-processing-flow",children:"Request Processing Flow"}),"\n",(0,r.jsx)(n.p,{children:"Fiber\u2019s request processing is designed for performance and minimal overhead. When an HTTP request is received by the underlying fasthttp server, the flow is as follows:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Request Arrival: The fasthttp server receives the HTTP request."}),"\n",(0,r.jsx)(n.li,{children:"Context Acquisition: The App calls AcquireCtx() to fetch a Context from the pool."}),"\n",(0,r.jsx)(n.li,{children:"Context Reset: The acquired Context is reset (via DefaultCtx.Reset()) with the new request\u2019s data."}),"\n",(0,r.jsx)(n.li,{children:"Request Handling: The request handler (default or custom) is invoked."}),"\n",(0,r.jsx)(n.li,{children:"Route Matching: The framework uses the next() (or nextCustom()) function to traverse the pre\u2011built route tree and find a matching route based on the URL and HTTP method."}),"\n",(0,r.jsx)(n.li,{children:"Middleware Chain Execution: The matched route\u2019s handler chain is executed in sequence."}),"\n",(0,r.jsx)(n.li,{children:"Error Handling (if required): Any errors encountered trigger the registered error handler."}),"\n",(0,r.jsx)(n.li,{children:"Response Generation: The response is sent back to the client."}),"\n",(0,r.jsx)(n.li,{children:"Context Release: Finally, the Context is cleaned up and returned to the pool."}),"\n"]}),"\n",(0,r.jsx)(n.mermaid,{value:'flowchart LR\n    R["HTTP Request (fasthttp)"]\n    A["App.RequestHandler<br/>(default or custom)"]\n    C["Acquire Context<br/>(from Pool)"]\n    X["Reset Context<br/>(DefaultCtx.Reset())"]\n    N["Route Matching<br/>(next() \\/ nextCustom())"]\n    M["Handler Chain Execution"]\n    EH["Error Handling<br/>(if needed)"]\n    S["HTTP Response"]\n    RC["Release Context<br/>(to Pool)"]\n\n    R --\x3e A\n    A --\x3e C\n    C --\x3e X\n    X --\x3e N\n    N --\x3e M\n    M --\x3e EH\n    EH --\x3e S\n    S --\x3e RC'}),"\n",(0,r.jsx)(n.h3,{id:"additional-note",children:"Additional Note"}),"\n",(0,r.jsx)(n.p,{children:"Fiber minimizes memory allocations by reusing Context objects and uses an optimized route\u2011matching algorithm to rapidly determine the correct handler chain."}),"\n",(0,r.jsx)(n.h2,{id:"routing--path-parsing",children:"Routing & Path Parsing"}),"\n",(0,r.jsx)(n.p,{children:"Fiber allows you to register routes using helper methods (e.g. Get(), Post()) or by creating groups and sub\u2011routers. Internally, the route pattern is parsed by the parseRoute() function. This function decomposes the route string into segments:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Constant Segments: Fixed parts of the path (e.g. /api)."}),"\n",(0,r.jsx)(n.li,{children:"Parameter Segments: Dynamic parts that begin with a colon. For example, a route may be defined as:\n/api/:userId<int>\nHere, the segment :userId<int> is a parameter segment with a type constraint (an integer)."}),"\n",(0,r.jsx)(n.li,{children:"Constraints: Constraints (such as int, bool, datetime, or even regular expressions) are extracted from the parameter part and stored in the route\u2019s metadata for validation at runtime."}),"\n"]}),"\n",(0,r.jsx)(n.mermaid,{value:'flowchart TD\n    P["Route Pattern String<br/>(e.g., \'/api/\\\\:userId\\\\&lt;int&gt;\')"]\n    PA["parseRoute()"]\n    RP[routeParser]\n    RS["routeSegment(s)"]\n    C["Constraints<br/>(e.g., int, datetime, regex)"]\n    PARAM[Extracted Parameter Names]\n\n    P --\x3e PA\n    PA --\x3e RP\n    RP --\x3e RS\n    RS --\x3e C\n    RP --\x3e PARAM'}),"\n",(0,r.jsx)(n.h3,{id:"explanation-1",children:"Explanation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"parseRoute(): Takes a route string and returns a routeParser struct that includes a list of routeSegment objects."}),"\n",(0,r.jsx)(n.li,{children:"routeSegment: Represents a portion of the route. If it is a parameter segment, it may include constraints that determine the allowed format (for example, ensuring that a parameter is an integer)."}),"\n",(0,r.jsx)(n.li,{children:"Extracted Parameter Names: These are later used to populate the request\u2019s Context with the actual values parsed from the URL."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"route-matching-and-parameter-extraction",children:"Route Matching and Parameter Extraction"}),"\n",(0,r.jsx)(n.p,{children:"When a request is processed, Fiber uses its pre\u2011computed route tree (the treeStack) to efficiently match the incoming URL against registered routes."}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Normalization: The URL is normalized (converted to lowercase, trailing slashes trimmed) to create a \u201Cdetection path.\u201D"}),"\n",(0,r.jsx)(n.li,{children:"Tree Traversal: The route tree, grouped by common prefixes, is traversed based on the HTTP method."}),"\n",(0,r.jsx)(n.li,{children:"Matching: Constant segments are compared exactly, while parameter segments extract dynamic values."}),"\n",(0,r.jsx)(n.li,{children:"Constraint Validation: Extracted parameter values are validated against any defined constraints."}),"\n"]}),"\n",(0,r.jsx)(n.mermaid,{value:'flowchart TD\n    A["Incoming Request URL<br/>(e.g., \'/api/john\')"]\n    B["Normalize URL<br/>(lowercase, trim trailing slashes)"]\n    C["Detection Path"]\n    D["Traverse Route Tree<br/>(treeStack based on method)"]\n    E["Match Constant Segments"]\n    F["Identify Parameter Segments<br/>(e.g., \':userId\')"]\n    G["Extract Parameter Values"]\n    H["Validate Constraints<br/>(e.g., \'int\', \'datetime\', \'regex\')"]\n    I["Route Found"]\n\n    A --\x3e B\n    B --\x3e C\n    C --\x3e D\n    D --\x3e E\n    E --\x3e F\n    F --\x3e G\n    G --\x3e H\n    H --\x3e I'}),"\n",(0,r.jsx)(n.h3,{id:"insight",children:"Insight"}),"\n",(0,r.jsx)(n.p,{children:"This efficient matching mechanism leverages pre\u2011grouped routes to minimize comparisons, while dynamic segments allow for flexible URL structures and runtime validation."}),"\n",(0,r.jsx)(n.h2,{id:"middleware-chain-execution",children:"Middleware Chain Execution"}),"\n",(0,r.jsx)(n.p,{children:"Once a matching route is found, Fiber executes the chain of middleware and route handlers sequentially. The process is as follows:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Initial Handler Execution: The first handler of the matched route is invoked."}),"\n",(0,r.jsx)(n.li,{children:"Calling Next(): Each handler calls Ctx.Next() to pass control to the next handler in the chain."}),"\n",(0,r.jsx)(n.li,{children:"Termination: When no further handlers remain, the chain terminates and the response is sent."}),"\n"]}),"\n",(0,r.jsx)(n.mermaid,{value:'flowchart TD\n    A[Matched Route]\n    B[Handler 1]\n    C[Handler 2]\n    D[Handler 3]\n    E[Response Generation]\n\n    A --\x3e B\n    B -- "Calls C via Next()" --\x3e C\n    C -- "Calls D via Next()" --\x3e D\n    D -- "No Next() available" --\x3e E'}),"\n",(0,r.jsx)(n.h3,{id:"explanation-2",children:"Explanation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Each handler in the chain can perform operations (e.g. authentication, logging, transformation) before calling Next() to forward control."}),"\n",(0,r.jsx)(n.li,{children:"This sequential processing ensures that middleware are executed in the order they were registered."}),"\n",(0,r.jsx)(n.li,{children:"If an error occurs or a handler does not call Next(), the chain may be terminated early, and an error handler may be invoked."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"observations",children:"Observations"}),"\n",(0,r.jsx)(n.p,{children:"Middleware are executed in the order they are registered. This sequential design allows each handler to perform tasks such as authentication, logging, or transformation before delegating to the next handler."}),"\n",(0,r.jsx)(n.h2,{id:"sub-application-mounting--grouping",children:"Sub-Application Mounting & Grouping"}),"\n",(0,r.jsx)(n.p,{children:"Fiber allows mounting sub\u2011applications (or sub\u2011routers) under specific path prefixes. This enables modular design of large APIs. The mounting process works as follows:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Defining a Mount Point: A parent application calls ",(0,r.jsx)(n.code,{children:"App.Mount()"})," or a Group calls its own ",(0,r.jsx)(n.code,{children:"mount()"})," method."]}),"\n",(0,r.jsx)(n.li,{children:"Merging Mount Fields: The sub\u2011app\u2019s mount fields are updated with the prefix of the parent, and its routes are integrated into the parent\u2019s routing structure."}),"\n",(0,r.jsx)(n.li,{children:"Processing Sub\u2011App Routes: During startup, the parent app collects routes from mounted sub\u2011apps and builds a unified route tree."}),"\n"]}),"\n",(0,r.jsx)(n.mermaid,{value:'flowchart TD\n    A[Parent App]\n    B["Sub-App (Mounted)"]\n    C["Define Mount Point<br/>(e.g. \\\'/admin\\\')"]\n    D["Update MountFields<br/>(assign mount path)"]\n    E["Merge Sub-App Routes<br/>(append to Router Stack)"]\n    F[Generate Unified Route Tree]\n\n    A --\x3e C\n    C --\x3e B\n    B --\x3e D\n    D --\x3e E\n    E --\x3e F'}),"\n",(0,r.jsx)(n.h3,{id:"impact",children:"Impact"}),"\n",(0,r.jsx)(n.p,{children:"This mechanism enables large APIs to be broken down into smaller, maintainable modules while still benefiting from Fiber\u2019s optimized routing and request handling."}),"\n",(0,r.jsx)(n.h2,{id:"route-tree-building",children:"Route Tree Building"}),"\n",(0,r.jsx)(n.p,{children:"Fiber builds a route tree (the treeStack) to optimize route matching. This involves grouping routes based on a prefix (usually the first few characters) to reduce the number of comparisons during a request."}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Iterating Over the Router Stack: Each registered route is examined."}),"\n",(0,r.jsx)(n.li,{children:"Computing the Tree Key: A key is computed from the route\u2019s normalized path (e.g. the first 3 characters)."}),"\n",(0,r.jsx)(n.li,{children:"Grouping Routes: Routes are added to the appropriate branch of the tree."}),"\n",(0,r.jsx)(n.li,{children:"Sorting: Within each group, routes are sorted based on their registration order (or position) to ensure the correct match is found."}),"\n"]}),"\n",(0,r.jsx)(n.mermaid,{value:'flowchart TD\n    A["Router Stack<br/>(All Registered Routes)"]\n    B["Compute Tree Key<br/>(e.g. first 3 characters)"]\n    C["Group Routes by Key<br/>(treeStack)"]\n    D["Merge Global Routes<br/>(key \\\'\\\' for global matches)"]\n    E[Sort Routes within Groups]\n    F[Optimized Route Tree]\n\n    A --\x3e B\n    B --\x3e C\n    C --\x3e D\n    D --\x3e E\n    E --\x3e F'}),"\n",(0,r.jsx)(n.h3,{id:"explanation-3",children:"Explanation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Building a route tree is an optimization step that reduces the matching overhead by limiting the search space to a subset of routes that share a common prefix."}),"\n",(0,r.jsx)(n.li,{children:"The tree is rebuilt whenever new routes are registered, ensuring that the latest routing configuration is always used for matching."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"context-lifecycle-management",children:"Context Lifecycle Management"}),"\n",(0,r.jsx)(n.p,{children:"Fiber minimizes allocations by pooling Context objects. The lifecycle of a Context is as follows:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Acquisition:"})," When a new HTTP request arrives, a Context is retrieved from the pool via ",(0,r.jsx)(n.code,{children:"App.AcquireCtx()"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reset:"})," The acquired Context is reset with the current ",(0,r.jsx)(n.code,{children:"fasthttp.RequestCtx"})," to clear previous data and initialize new request\u2011specific values."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Processing:"})," The Context is passed along the middleware and handler chain."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Release:"})," After processing the request (or when an error occurs), the Context is released back to the pool via ",(0,r.jsx)(n.code,{children:"App.ReleaseCtx()"}),", making it available for reuse."]}),"\n"]}),"\n",(0,r.jsx)(n.mermaid,{value:'flowchart TD\n    A["HTTP Request<br/>(fasthttp)"]\n    B["Acquire Context<br/>(App.AcquireCtx())"]\n    C["Reset Context<br/>(DefaultCtx.Reset())"]\n    D["Process Request<br/>(Handlers & Middleware)"]\n    E["Error Handling<br/>(if needed)"]\n    F["Release Context<br/>(App.ReleaseCtx())"]\n\n    A --\x3e B\n    B --\x3e C\n    C --\x3e D\n    D --\x3e E\n    E --\x3e F'}),"\n",(0,r.jsx)(n.h3,{id:"key-benefit",children:"Key Benefit"}),"\n",(0,r.jsx)(n.p,{children:"Reusing Context objects significantly reduces garbage collection overhead, ensuring Fiber remains fast and memory\u2011efficient even under heavy load."}),"\n",(0,r.jsx)(n.h2,{id:"preforking-mechanism",children:"Preforking Mechanism"}),"\n",(0,r.jsx)(n.p,{children:"To take full advantage of multi\u2011core systems, Fiber offers a prefork mode. In this mode, the master process spawns several child processes that listen on the same port using OS features such as SO_REUSEPORT (or fall back to SO_REUSEADDR)."}),"\n",(0,r.jsx)(n.mermaid,{value:'flowchart LR\n    M["Master Process (App)"]\n    C[Child Processes]\n    GOMAX["Set GOMAXPROCS(1)"]\n    REQ[Handle HTTP Requests]\n    WM["watchMaster()"]\n\n    M --\x3e|Spawns| C\n    C --\x3e GOMAX\n    C --\x3e|Processes| REQ\n    C --\x3e WM'}),"\n",(0,r.jsx)(n.h3,{id:"explanation-4",children:"Explanation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Master Process: The main process determines the number of available CPU cores and spawns that many child processes."}),"\n",(0,r.jsx)(n.li,{children:"Child Processes: Each child sets GOMAXPROCS(1) to run on a single CPU core and listens on the shared port."}),"\n",(0,r.jsx)(n.li,{children:"watchMaster(): Each child process runs a watchdog routine to monitor the master process; if the master exits (or its parent process ID becomes 1 on Unix\u2011like systems), the child terminates gracefully."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"detailed-preforking-workflow",children:"Detailed Preforking Workflow"}),"\n",(0,r.jsx)(n.p,{children:"Fiber\u2019s prefork mode uses OS\u2011level mechanisms to allow multiple processes to listen on the same port. Here\u2019s a more detailed look:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Master Process Spawning: The master process detects the number of CPU cores and spawns that many child processes."}),"\n",(0,r.jsx)(n.li,{children:"Child Process Initialization: Each child process sets GOMAXPROCS(1) so that it runs on a single core."}),"\n",(0,r.jsx)(n.li,{children:"Binding to Port: Child processes use packages like reuseport to bind to the same address and port."}),"\n",(0,r.jsx)(n.li,{children:"Parent Monitoring: Each child runs a watchdog function (watchMaster()) to monitor the master process; if the master terminates, children exit."}),"\n",(0,r.jsx)(n.li,{children:"Request Handling: Each child independently handles incoming HTTP requests."}),"\n"]}),"\n",(0,r.jsx)(n.mermaid,{value:'flowchart TD\n    A[Master Process]\n    B[Determine CPU Cores]\n    C[Spawn Child Processes]\n    D["Child Process Initialization<br/>(GOMAXPROCS(1))"]\n    E["Bind to Port<br/>(reuseport)"]\n    F["Run watchMaster()<br/>(Monitor Parent)"]\n    G[Handle HTTP Requests]\n\n    A --\x3e B\n    B --\x3e C\n    C --\x3e D\n    D --\x3e E\n    E --\x3e F\n    F --\x3e G'}),"\n",(0,r.jsx)(n.h4,{id:"explanation-5",children:"Explanation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Preforking improves performance by allowing multiple processes to handle requests concurrently."}),"\n",(0,r.jsx)(n.li,{children:"Using reuseport (or a fallback) ensures that all child processes can listen on the same port without conflicts."}),"\n",(0,r.jsx)(n.li,{children:"The watchdog routine in each child ensures that they exit if the master process is no longer running, maintaining process integrity."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"redirection--flash-messages",children:"Redirection & Flash Messages"}),"\n",(0,r.jsx)(n.p,{children:"Fiber\u2019s redirection mechanism is implemented via the Redirect struct. This structure allows not only setting a new location for redirection but also passing along flash messages and old input data via a special cookie."}),"\n",(0,r.jsx)(n.mermaid,{value:'flowchart LR\n    R[Redirect Struct]\n    RP[redirectPool]\n    FM["Flash Messages \\/ Old Inputs"]\n    M["Methods:<br/>To(), Route(), Back()"]\n    LH[Set Location Header]\n    CK["Flash Cookie<br/>(fiber\\_flash)"]\n\n    R --\x3e|Acquired from| RP\n    R --\x3e FM\n    R --\x3e M\n    M --\x3e LH\n    FM --\x3e|Serialized| CK'}),"\n",(0,r.jsx)(n.h3,{id:"explanation-6",children:"Explanation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Redirect Struct: Retrieved from a pool (to minimize allocations), it stores redirection settings such as the HTTP status code (defaulting to 303 See Other) and any flash messages."}),"\n",(0,r.jsx)(n.li,{children:"Flash Messages & Old Inputs: These are collected via methods like With() or WithInput() and then serialized and stored in a cookie named fiber_flash."}),"\n",(0,r.jsx)(n.li,{children:"Redirection Methods: The To(), Route(), and Back() methods determine the target URL and set the Location header accordingly."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"flash-message-handling-in-redirection",children:"Flash Message Handling in Redirection"}),"\n",(0,r.jsx)(n.p,{children:"When performing redirections, Fiber can send flash messages or preserve old input data. This process involves:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Collecting Flash Data: When a redirect is initiated, developers can add flash messages via Redirect.With() or old input data via Redirect.WithInput()."}),"\n",(0,r.jsx)(n.li,{children:"Serialization: The flash messages and input data are serialized (using a fast marshalling method) into a byte sequence."}),"\n",(0,r.jsx)(n.li,{children:"Setting a Cookie: The serialized data is stored in a special cookie (named fiber_flash) that will be sent to the client."}),"\n",(0,r.jsx)(n.li,{children:"Retrieval & Clearing: On the subsequent request, the flash data is read from the cookie, deserialized, and then cleared."}),"\n"]}),"\n",(0,r.jsx)(n.mermaid,{value:'flowchart TD\n    A[Initiate Redirect]\n    B["Add Flash Messages<br/>(With(), WithInput())"]\n    C[Serialize Flash Data]\n    D["Set Flash Cookie<br/>(\\\'fiber\\_flash\\\')"]\n    E[Client Receives Redirect]\n    F[Next Request Reads Flash Cookie]\n    G["Deserialize & Clear Flash Data"]\n\n    A --\x3e B\n    B --\x3e C\n    C --\x3e D\n    D --\x3e E\n    E --\x3e F\n    F --\x3e G'}),"\n",(0,r.jsx)(n.h4,{id:"explanation-7",children:"Explanation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Flash messages provide a way to pass transient data (such as notifications or error messages) to the next request after a redirect."}),"\n",(0,r.jsx)(n.li,{children:"The data is stored temporarily in a cookie, which is then read and cleared upon processing the next request."}),"\n",(0,r.jsx)(n.li,{children:"This mechanism is essential for implementing post\u2011redirect\u2011get patterns and ensuring a smooth user experience."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"hooks-error-handling--context-lifecycle",children:"Hooks, Error Handling & Context Lifecycle"}),"\n",(0,r.jsx)(n.h3,{id:"hooks",children:"Hooks"}),"\n",(0,r.jsx)(n.p,{children:"Fiber provides a comprehensive hook system that allows you to run custom functions at key moments:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"OnRoute: Called when a route is registered."}),"\n",(0,r.jsx)(n.li,{children:"OnName: Invoked when a route is assigned a name."}),"\n",(0,r.jsx)(n.li,{children:"OnGroup: Triggered when a group is created."}),"\n",(0,r.jsx)(n.li,{children:"OnListen: Runs when the server starts listening."}),"\n",(0,r.jsx)(n.li,{children:"OnShutdown: Called during graceful shutdown."}),"\n",(0,r.jsx)(n.li,{children:"OnFork: Invoked when a child process is forked."}),"\n",(0,r.jsx)(n.li,{children:"OnMount: Used when a sub\u2011application is mounted."}),"\n"]}),"\n",(0,r.jsx)(n.mermaid,{value:"flowchart TD\n    H[Hooks]\n    OR[OnRoute]\n    ON[OnName]\n    OG[OnGroup]\n    OL[OnListen]\n    OS[OnShutdown]\n    OF[OnFork]\n    OM[OnMount]\n\n    H --\x3e OR\n    H --\x3e ON\n    H --\x3e OG\n    H --\x3e OL\n    H --\x3e OS\n    H --\x3e OF\n    H --\x3e OM"}),"\n",(0,r.jsx)(n.h4,{id:"explanation-8",children:"Explanation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Hooks provide extension points for developers and maintainers to inject custom logic without modifying the core Fiber code."}),"\n",(0,r.jsx)(n.li,{children:"They are executed at various stages (for example, every time a new route is registered, the OnRoute hooks are executed to allow for logging, validation, or transformation of the route)."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"error-handling--context-lifecycle",children:"Error Handling & Context Lifecycle"}),"\n",(0,r.jsx)(n.p,{children:"Fiber\u2019s DefaultCtx (or CustomCtx) represents the per\u2011request context. The lifecycle is as follows:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Acquire: A Context is obtained from the pool at the beginning of a request."}),"\n",(0,r.jsx)(n.li,{children:"Processing: The context is passed along to the route handlers and middleware."}),"\n",(0,r.jsx)(n.li,{children:"Error Handling: If an error occurs (e.g., route not found, method not allowed, or a panic in the handler), Fiber calls the registered error handler. Errors such as ErrMethodNotAllowed or StatusNotFound are generated as needed."}),"\n",(0,r.jsx)(n.li,{children:"Release: Once the request is processed, the Context is released back into the pool for reuse."}),"\n"]}),"\n",(0,r.jsx)(n.mermaid,{value:'flowchart LR\n    AC["Acquire Context<br/>(from Pool)"]\n    HP["Handle Request<br/>(Handlers & Middleware)"]\n    EH["Error Handling<br/>(if needed)"]\n    RC["Release Context<br/>(to Pool)"]\n\n    AC --\x3e HP\n    HP --\x3e EH\n    EH --\x3e RC'}),"\n",(0,r.jsx)(n.h4,{id:"explanation-9",children:"Explanation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"This lifecycle ensures that Fiber minimizes allocations by reusing Context objects."}),"\n",(0,r.jsx)(n.li,{children:"Errors are propagated and handled consistently, and the context is properly reset after every request."}),"\n"]})]})}function h(e={}){let{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},84429:function(e,n,t){t.d(n,{R:()=>a,x:()=>o});var i=t(96540);let r={},s=i.createContext(r);function a(e){let n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);