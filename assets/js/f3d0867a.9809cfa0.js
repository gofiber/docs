"use strict";(self.webpackChunkfiber_docs=self.webpackChunkfiber_docs||[]).push([["7189"],{65412:function(e,n,r){r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var i=r(37713),t=r(74848),a=r(84429);let s={slug:"fiber-v3-binding-in-practice",title:"Binding in Practice",authors:["fiber-team"],tags:["fiber","v3","binding","api","go"],description:"Use Bind methods to make request handling consistent and easier to maintain."},d,o={authorsImageUrls:[void 0]},l=[{value:"What v2 Parsing Looked Like",id:"what-v2-parsing-looked-like",level:2},{value:"Focused Source Binding",id:"focused-source-binding",level:2},{value:"Multi-Source Binding with <code>Bind().All()</code>",id:"multi-source-binding-with-bindall",level:2},{value:"Built-in Validation",id:"built-in-validation",level:2},{value:"Default Values",id:"default-values",level:2},{value:"Custom Binders for Non-Standard Formats",id:"custom-binders-for-non-standard-formats",level:2},{value:"CBOR and MsgPack Support",id:"cbor-and-msgpack-support",level:2},{value:"A Handler Shape That Scales",id:"a-handler-shape-that-scales",level:2},{value:"Where to Start",id:"where-to-start",level:2},{value:"Internal References",id:"internal-references",level:2}];function c(e){let n={a:"a",code:"code",h2:"h2",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Request parsing is one of the easiest places to create hidden technical debt."}),"\n",(0,t.jsxs)(n.p,{children:["At the beginning of a project, mixed parsing styles seem harmless. A quick ",(0,t.jsx)(n.code,{children:"c.Query()"})," here, a manual ",(0,t.jsx)(n.code,{children:"json.Unmarshal(c.Body(), &req)"})," there, a ",(0,t.jsx)(n.code,{children:"c.Params()"})," somewhere else. After enough endpoints, input behavior becomes unpredictable. One handler parses the body with a JSON decoder, another uses form tags, a third reads query parameters with individual calls. When bugs appear, you have to trace parsing logic per endpoint instead of trusting a shared convention."]}),"\n",(0,t.jsxs)(n.p,{children:["Fiber v3 binding exists to make that convention explicit. ",(0,t.jsx)(n.code,{children:"c.Bind()"})," is not just a new method name. It is a structured API that supports every input source, has defined precedence rules, integrates validation, and supports custom decoders. If your team agrees on binding, input handling stops being a source of surprises."]}),"\n",(0,t.jsx)(n.h2,{id:"what-v2-parsing-looked-like",children:"What v2 Parsing Looked Like"}),"\n",(0,t.jsx)(n.p,{children:"In v2, request data parsing used individual methods on the context:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'// v2: scattered parsing methods\nfunc handler(c *fiber.Ctx) error {\n    name := c.Query("name")\n    id, _ := c.ParamsInt("id")\n\n    var body RequestBody\n    if err := c.BodyParser(&body); err != nil {\n        return err\n    }\n\n    role := c.Get("X-Role")\n    session := c.Cookies("session_id")\n    // ...\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Each source had its own method, its own error behavior, and its own conventions. Teams that worked across many endpoints often ended up with inconsistent parsing: some handlers used ",(0,t.jsx)(n.code,{children:"BodyParser"}),", others called ",(0,t.jsx)(n.code,{children:"json.Unmarshal"})," directly, and a few mixed query and body parsing without clear precedence."]}),"\n",(0,t.jsx)(n.p,{children:"v3 replaces these with a unified binding API where you declare the source explicitly and the framework handles parsing, type conversion, and validation."}),"\n",(0,t.jsx)(n.h2,{id:"focused-source-binding",children:"Focused Source Binding"}),"\n",(0,t.jsx)(n.p,{children:"The most readable pattern is binding from a single, specific source:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'type ListUsersQuery struct {\n    Page  int    `query:"page"`\n    Limit int    `query:"limit"`\n    Sort  string `query:"sort"`\n}\n\napp.Get("/users", func(c fiber.Ctx) error {\n    q := new(ListUsersQuery)\n    if err := c.Bind().Query(q); err != nil {\n        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": err.Error()})\n    }\n\n    return c.JSON(fiber.Map{"query": q})\n})\n'})}),"\n",(0,t.jsxs)(n.p,{children:["This pattern makes intent obvious: this endpoint only cares about query input. The struct tags document the source, and the ",(0,t.jsx)(n.code,{children:"Bind().Query()"})," call makes parsing explicit in the handler."]}),"\n",(0,t.jsx)(n.p,{children:"The same pattern works for every source:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"c.Bind().Body(out)"})," \u2014 JSON, XML, form, multipart, MsgPack, CBOR (content-type auto-detected)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"c.Bind().Query(out)"})," \u2014 URL query parameters"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"c.Bind().Header(out)"})," \u2014 request headers"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"c.Bind().Cookie(out)"})," \u2014 cookies"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"c.Bind().URI(out)"})," \u2014 URL path parameters"]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"multi-source-binding-with-bindall",children:["Multi-Source Binding with ",(0,t.jsx)(n.code,{children:"Bind().All()"})]}),"\n",(0,t.jsxs)(n.p,{children:["When an endpoint needs data from multiple sources, ",(0,t.jsx)(n.code,{children:"All()"})," binds from every source with a defined precedence:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'type UserInput struct {\n    ID    int    `uri:"id" json:"id" query:"id"`\n    Name  string `json:"name" form:"name" query:"name"`\n    Role  string `header:"X-Role"`\n    Token string `cookie:"session_token"`\n}\n\napp.Post("/users/:id", func(c fiber.Ctx) error {\n    in := new(UserInput)\n    if err := c.Bind().All(in); err != nil {\n        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": err.Error()})\n    }\n\n    return c.JSON(in)\n})\n'})}),"\n",(0,t.jsx)(n.p,{children:"The precedence order is fixed by the framework:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"URI parameters"}),"\n",(0,t.jsx)(n.li,{children:"Request body"}),"\n",(0,t.jsx)(n.li,{children:"Query parameters"}),"\n",(0,t.jsx)(n.li,{children:"Headers"}),"\n",(0,t.jsx)(n.li,{children:"Cookies"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"That means if the same field name appears in both the URI and the query string, the URI value wins. This is a framework contract, not something you have to remember or document per handler. It removes a class of ambiguity bugs in mixed-source endpoints."}),"\n",(0,t.jsx)(n.h2,{id:"built-in-validation",children:"Built-in Validation"}),"\n",(0,t.jsx)(n.p,{children:"Binding integrates with struct validation. You configure a validator once at app level, then every binding call runs validation automatically:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'import "github.com/go-playground/validator/v10"\n\ntype structValidator struct {\n    validate *validator.Validate\n}\n\nfunc (v *structValidator) Validate(out any) error {\n    return v.validate.Struct(out)\n}\n\napp := fiber.New(fiber.Config{\n    StructValidator: &structValidator{validate: validator.New()},\n})\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Now your input structs can use ",(0,t.jsx)(n.code,{children:"validate"})," tags:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'type CreateUser struct {\n    Name  string `json:"name" validate:"required"`\n    Email string `json:"email" validate:"required,email"`\n    Age   int    `json:"age" validate:"gte=18,lte=120"`\n}\n\napp.Post("/users", func(c fiber.Ctx) error {\n    u := new(CreateUser)\n    if err := c.Bind().Body(u); err != nil {\n        // includes both parse errors and validation errors\n        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": err.Error()})\n    }\n\n    return c.JSON(u)\n})\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The validation runs after parsing, so a single ",(0,t.jsx)(n.code,{children:"Bind().Body()"})," call handles both deserialization and validation. No separate validation step, no risk of forgetting to validate in one handler."]}),"\n",(0,t.jsx)(n.h2,{id:"default-values",children:"Default Values"}),"\n",(0,t.jsxs)(n.p,{children:["Binding supports default values via the ",(0,t.jsx)(n.code,{children:"default"})," struct tag. This is useful for pagination and optional filters:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'type SearchQuery struct {\n    Page     int      `query:"page,default:1"`\n    Limit    int      `query:"limit,default:20"`\n    Tags     []string `query:"tags,default:latest|featured"`\n}\n\napp.Get("/search", func(c fiber.Ctx) error {\n    q := new(SearchQuery)\n    if err := c.Bind().Query(q); err != nil {\n        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": err.Error()})\n    }\n\n    // q.Page is 1 if not provided, q.Tags is ["latest", "featured"]\n    return c.JSON(q)\n})\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Defaults are applied before validation, so a field with a default value will pass ",(0,t.jsx)(n.code,{children:"required"})," validation even if the client did not send it. Slice defaults use ",(0,t.jsx)(n.code,{children:"|"})," as separator."]}),"\n",(0,t.jsx)(n.h2,{id:"custom-binders-for-non-standard-formats",children:"Custom Binders for Non-Standard Formats"}),"\n",(0,t.jsx)(n.p,{children:"If your API accepts formats beyond JSON, XML, and form data, you can register custom binders. A YAML binder, for example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'type yamlBinder struct{}\n\nfunc (y *yamlBinder) Name() string          { return "yaml" }\nfunc (y *yamlBinder) MIMETypes() []string   { return []string{"application/yaml"} }\nfunc (y *yamlBinder) Parse(c fiber.Ctx, out any) error {\n    return yaml.Unmarshal(c.Body(), out)\n}\n\napp.RegisterCustomBinder(&yamlBinder{})\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Once registered, ",(0,t.jsx)(n.code,{children:"Bind().Body()"})," auto-detects ",(0,t.jsx)(n.code,{children:"application/yaml"})," content and uses your binder. You can also call it explicitly with ",(0,t.jsx)(n.code,{children:'Bind().Custom("yaml", &out)'}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"cbor-and-msgpack-support",children:"CBOR and MsgPack Support"}),"\n",(0,t.jsxs)(n.p,{children:["Fiber v3 natively supports ",(0,t.jsx)(n.a,{href:"https://cbor.io/",children:"CBOR"})," and ",(0,t.jsx)(n.a,{href:"https://msgpack.org/",children:"MsgPack"})," in addition to JSON, XML, and form data. These binary formats are more compact and faster to parse, which makes them practical for high-throughput internal APIs:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'type Event struct {\n    Type string `json:"type" msgpack:"type" cbor:"type"`\n    Data []byte `json:"data" msgpack:"data" cbor:"data"`\n}\n\napp.Post("/events", func(c fiber.Ctx) error {\n    e := new(Event)\n    if err := c.Bind().Body(e); err != nil {\n        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": err.Error()})\n    }\n\n    return c.JSON(e)\n})\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The correct binder is selected automatically based on the ",(0,t.jsx)(n.code,{children:"Content-Type"})," header. No handler changes are needed to support multiple formats."]}),"\n",(0,t.jsx)(n.h2,{id:"a-handler-shape-that-scales",children:"A Handler Shape That Scales"}),"\n",(0,t.jsx)(n.p,{children:"A stable pattern across all endpoints is: bind input, validate, execute logic, map response."}),"\n",(0,t.jsx)(n.mermaid,{value:'flowchart LR\n    A["Request arrives"] --\x3e B["c.Bind parses input"]\n    B --\x3e C{"Validation passes?"}\n    C -- no --\x3e D["Return 400 with error"]\n    C -- yes --\x3e E["Execute business logic"]\n    E --\x3e F["Return JSON response"]'}),"\n",(0,t.jsx)(n.p,{children:"When every endpoint follows this shape, onboarding gets easier and reviews become faster because the structure is predictable. If someone adds a handler that skips binding or validates differently, it stands out immediately."}),"\n",(0,t.jsx)(n.h2,{id:"where-to-start",children:"Where to Start"}),"\n",(0,t.jsx)(n.p,{children:"Start with endpoints that currently parse from multiple sources (path + body + header). They get the biggest reliability gain from moving to explicit binding. Then add a struct validator to catch input errors before they reach business logic."}),"\n",(0,t.jsx)(n.h2,{id:"internal-references",children:"Internal References"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/api/bind",children:"Bind API"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/api/ctx",children:"Ctx API"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/whats_new",children:"What's New"})}),"\n"]})]})}function u(e={}){let{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},84429:function(e,n,r){r.d(n,{R:()=>s,x:()=>d});var i=r(96540);let t={},a=i.createContext(t);function s(e){let n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(a.Provider,{value:n},e.children)}},37713:function(e){e.exports=JSON.parse('{"permalink":"/blog/fiber-v3-binding-in-practice","editUrl":"https://github.com/gofiber/docs/tree/master/blog/2026-02-16-fiber-v3-binding-in-practice.md","source":"@site/blog/2026-02-16-fiber-v3-binding-in-practice.md","title":"Binding in Practice","description":"Use Bind methods to make request handling consistent and easier to maintain.","date":"2026-02-16T00:00:00.000Z","tags":[{"inline":true,"label":"fiber","permalink":"/blog/tags/fiber"},{"inline":true,"label":"v3","permalink":"/blog/tags/v-3"},{"inline":true,"label":"binding","permalink":"/blog/tags/binding"},{"inline":true,"label":"api","permalink":"/blog/tags/api"},{"inline":true,"label":"go","permalink":"/blog/tags/go"}],"readingTime":5.57,"hasTruncateMarker":true,"authors":[{"name":"Fiber Team","title":"Maintainers","url":"https://github.com/gofiber/fiber","imageURL":"https://github.com/gofiber.png","key":"fiber-team","page":null}],"frontMatter":{"slug":"fiber-v3-binding-in-practice","title":"Binding in Practice","authors":["fiber-team"],"tags":["fiber","v3","binding","api","go"],"description":"Use Bind methods to make request handling consistent and easier to maintain."},"unlisted":false,"prevItem":{"title":"Custom Context in Practice","permalink":"/blog/fiber-v3-custom-context"},"nextItem":{"title":"New Client Deep Dive","permalink":"/blog/fiber-v3-client-deep-dive"}}')}}]);