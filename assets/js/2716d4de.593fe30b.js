"use strict";(self.webpackChunkfiber_docs=self.webpackChunkfiber_docs||[]).push([["31279"],{3547:function(e,t,n){n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>d});var r=n(25400),i=n(74848),a=n(84429);let s={slug:"build-a-crud-app-with-fiber",title:"Build a CRUD API with Fiber",authors:["fiber-team"],tags:["fiber","v3","crud","gorm","postgres","go"],description:"Build a practical CRUD API in Fiber v3 and keep the request flow understandable as it grows."},o,l={authorsImageUrls:[void 0]},d=[{value:"What We Are Building",id:"what-we-are-building",level:2},{value:"Why Route Structure Matters More Than People Think",id:"why-route-structure-matters-more-than-people-think",level:2},{value:"Input Handling: What Changed from v2",id:"input-handling-what-changed-from-v2",level:2},{value:"What Actually Happens in a CRUD Request",id:"what-actually-happens-in-a-crud-request",level:2},{value:"Run Locally",id:"run-locally",level:2},{value:"Smoke Tests That Are Worth Running",id:"smoke-tests-that-are-worth-running",level:2},{value:"Practical Lessons Before You Ship This Pattern",id:"practical-lessons-before-you-ship-this-pattern",level:2},{value:"Recipe and Next Step",id:"recipe-and-next-step",level:2}];function c(e){let t={a:"a",code:"code",h2:"h2",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"CRUD APIs are often where a backend project either becomes maintainable or becomes expensive."}),"\n",(0,i.jsx)(t.p,{children:"At first, everything feels easy: a quick route, a quick DB call, done. Three months later, handlers parse requests in different ways, errors are inconsistent, and every change takes twice as long as expected."}),"\n",(0,i.jsx)(t.p,{children:"This post is about avoiding that path from the start."}),"\n",(0,i.jsxs)(t.p,{children:["We'll use Fiber v3 with the ",(0,i.jsx)(t.code,{children:"gorm-postgres"}),' recipe, but the real goal is not just to "get CRUD working." The goal is to set up a structure your team can still understand when the API grows.']}),"\n",(0,i.jsx)(t.h2,{id:"what-we-are-building",children:"What We Are Building"}),"\n",(0,i.jsx)(t.p,{children:"A simple books API with five operations:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"create a book"}),"\n",(0,i.jsx)(t.li,{children:"list all books"}),"\n",(0,i.jsx)(t.li,{children:"query by title"}),"\n",(0,i.jsx)(t.li,{children:"update a book"}),"\n",(0,i.jsx)(t.li,{children:"delete a book"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Nothing here is technically complex. That is exactly why it is a good example: if the simple path is clean, the complex path gets easier later."}),"\n",(0,i.jsx)(t.h2,{id:"why-route-structure-matters-more-than-people-think",children:"Why Route Structure Matters More Than People Think"}),"\n",(0,i.jsx)(t.p,{children:"In early APIs, teams usually focus on handler internals and ignore route shape. Then versioning starts, clients depend on edge-case behavior, and cleanup gets painful."}),"\n",(0,i.jsx)(t.p,{children:"The recipe keeps route registration explicit in one place:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-go",children:'func setUpRoutes(app *fiber.App) {\n    app.Get("/hello", routes.Hello)\n    app.Get("/allbooks", routes.AllBooks)\n    app.Post("/addbook", routes.AddBook)\n    app.Post("/book", routes.Book)\n    app.Put("/update", routes.Update)\n    app.Delete("/delete", routes.Delete)\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"That explicit list gives you two advantages immediately:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"onboarding gets faster because route intent is visible in one file"}),"\n",(0,i.jsxs)(t.li,{children:["versioning is straightforward later (",(0,i.jsx)(t.code,{children:"/api/v1"}),", ",(0,i.jsx)(t.code,{children:"/api/v2"}),") because your boundary is already clear"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["A note on route naming: the recipe uses action-based paths like ",(0,i.jsx)(t.code,{children:"/addbook"})," and ",(0,i.jsx)(t.code,{children:"/allbooks"}),", which works well for learning. In production, RESTful resource-based paths (",(0,i.jsx)(t.code,{children:"GET /books"}),", ",(0,i.jsx)(t.code,{children:"POST /books"}),", ",(0,i.jsx)(t.code,{children:"GET /books/:id"}),", ",(0,i.jsx)(t.code,{children:"PUT /books/:id"}),", ",(0,i.jsx)(t.code,{children:"DELETE /books/:id"}),") are usually a better choice because they map naturally to HTTP semantics and make API documentation cleaner. The migration from one style to the other is straightforward when routes are centralized like this."]}),"\n",(0,i.jsx)(t.h2,{id:"input-handling-what-changed-from-v2",children:"Input Handling: What Changed from v2"}),"\n",(0,i.jsxs)(t.p,{children:["In v2, body parsing used ",(0,i.jsx)(t.code,{children:"c.BodyParser()"}),", query parameters used individual ",(0,i.jsx)(t.code,{children:"c.Query()"})," calls, and path parameters used ",(0,i.jsx)(t.code,{children:"c.ParamsInt()"}),". Each had different error behavior and conventions."]}),"\n",(0,i.jsxs)(t.p,{children:["v3 unifies all of this under ",(0,i.jsx)(t.code,{children:"c.Bind()"}),". The recipe handler shows the pattern:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-go",children:'func AddBook(c fiber.Ctx) error {\n    book := new(models.Book)\n\n    if err := c.Bind().Body(book); err != nil {\n        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": err.Error()})\n    }\n\n    if result := database.DB.Db.Create(book); result.Error != nil {\n        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{\n            "error": "failed to create book",\n            "code":  "CREATE_FAILED",\n        })\n    }\n    return c.Status(fiber.StatusCreated).JSON(book)\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"This may look trivial, but the consistency matters. Every handler follows the same shape: bind input, check for errors, run logic, return response. When your team agrees on this pattern, code reviews get shorter and parsing bugs become rare."}),"\n",(0,i.jsxs)(t.p,{children:["If you need validation beyond what struct tags provide, Fiber v3 supports built-in validation through the ",(0,i.jsx)(t.code,{children:"StructValidator"})," config. You configure it once at app level and every ",(0,i.jsx)(t.code,{children:"Bind()"})," call automatically validates:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-go",children:'type CreateBook struct {\n    Title  string `json:"title" validate:"required"`\n    Author string `json:"author" validate:"required"`\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["See the ",(0,i.jsx)(t.a,{href:"/blog/fiber-v3-binding-in-practice",children:"Binding in Practice"})," post for the full validation setup."]}),"\n",(0,i.jsx)(t.h2,{id:"what-actually-happens-in-a-crud-request",children:"What Actually Happens in a CRUD Request"}),"\n",(0,i.jsx)(t.mermaid,{value:'flowchart LR\n    A["Client sends JSON"] --\x3e B["Fiber matches route"]\n    B --\x3e C["c.Bind().Body parses payload"]\n    C --\x3e D{"Payload valid?"}\n    D -- no --\x3e E["Return 400"]\n    D -- yes --\x3e F["Run GORM operation"]\n    F --\x3e G["PostgreSQL"]\n    G --\x3e H["Return JSON response"]'}),"\n",(0,i.jsx)(t.p,{children:"The key design choice is where errors are handled. Do not push parse/validation errors too deep. If they are request-shape errors, fail early and return stable responses."}),"\n",(0,i.jsx)(t.h2,{id:"run-locally",children:"Run Locally"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:"git clone https://github.com/gofiber/recipes.git\ncd recipes/gorm-postgres\ngo run app.go\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The recipe expects local Postgres defaults. If your environment differs, adjust DSN settings in ",(0,i.jsx)(t.code,{children:"database/database.go"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"smoke-tests-that-are-worth-running",children:"Smoke Tests That Are Worth Running"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:'# Create\ncurl -i -X POST http://localhost:3000/addbook \\\n  -H \'Content-Type: application/json\' \\\n  -d \'{"title":"Distributed Systems","author":"Tanenbaum"}\'\n\n# Read all\ncurl -i http://localhost:3000/allbooks\n\n# Read by title\ncurl -i -X POST http://localhost:3000/book \\\n  -H \'Content-Type: application/json\' \\\n  -d \'{"title":"Distributed Systems"}\'\n\n# Update\ncurl -i -X PUT http://localhost:3000/update \\\n  -H \'Content-Type: application/json\' \\\n  -d \'{"title":"Distributed Systems","author":"A. Tanenbaum"}\'\n\n# Delete\ncurl -i -X DELETE http://localhost:3000/delete \\\n  -H \'Content-Type: application/json\' \\\n  -d \'{"title":"Distributed Systems"}\'\n'})}),"\n",(0,i.jsx)(t.p,{children:"These are not just demo commands. They are a minimum regression checklist for any CRUD service before merging route changes."}),"\n",(0,i.jsx)(t.h2,{id:"practical-lessons-before-you-ship-this-pattern",children:"Practical Lessons Before You Ship This Pattern"}),"\n",(0,i.jsxs)(t.p,{children:["The recipe updates and deletes by title. That is fine for learning, but in production you should usually move to immutable identifiers (numeric ID, UUID, ULID). Fiber v3 supports ",(0,i.jsx)(t.a,{href:"/blog/whats-new-in-fiber-v3#8-custom-route-constraints",children:"custom route constraints"})," that can validate identifier formats at the routing layer, so invalid IDs never reach your handler."]}),"\n",(0,i.jsx)(t.p,{children:"Avoid sending raw database errors to clients. A stable error envelope makes frontend integration predictable and simplifies incident handling:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-go",children:'// consistent error response shape\nreturn c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{\n    "error": "failed to create book",\n    "code":  "CREATE_FAILED",\n})\n'})}),"\n",(0,i.jsx)(t.p,{children:"Finally, if you add auth/validation middleware later, keep the same flow discipline: bind input, validate, execute logic, map response. That consistency is what makes the codebase scale."}),"\n",(0,i.jsx)(t.h2,{id:"recipe-and-next-step",children:"Recipe and Next Step"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Primary reference: ",(0,i.jsx)(t.a,{href:"https://github.com/gofiber/recipes/tree/master/gorm-postgres",children:"gofiber/recipes/gorm-postgres"})]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["A strong next step is to add validation (see ",(0,i.jsx)(t.a,{href:"/blog/fiber-v3-binding-in-practice",children:"Binding in Practice"}),") and move routes under ",(0,i.jsx)(t.code,{children:"/api/v1"})," with consistent response envelopes (",(0,i.jsx)(t.code,{children:"data"}),", ",(0,i.jsx)(t.code,{children:"error"}),", ",(0,i.jsx)(t.code,{children:"meta"}),"). That gives you a cleaner base before feature count grows."]})]})}function h(e={}){let{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},84429:function(e,t,n){n.d(t,{R:()=>s,x:()=>o});var r=n(96540);let i={},a=r.createContext(i);function s(e){let t=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(a.Provider,{value:t},e.children)}},25400:function(e){e.exports=JSON.parse('{"permalink":"/blog/build-a-crud-app-with-fiber","editUrl":"https://github.com/gofiber/docs/tree/master/blog/2026-02-12-build-a-crud-app-with-fiber.md","source":"@site/blog/2026-02-12-build-a-crud-app-with-fiber.md","title":"Build a CRUD API with Fiber","description":"Build a practical CRUD API in Fiber v3 and keep the request flow understandable as it grows.","date":"2026-02-12T00:00:00.000Z","tags":[{"inline":true,"label":"fiber","permalink":"/blog/tags/fiber"},{"inline":true,"label":"v3","permalink":"/blog/tags/v-3"},{"inline":true,"label":"crud","permalink":"/blog/tags/crud"},{"inline":true,"label":"gorm","permalink":"/blog/tags/gorm"},{"inline":true,"label":"postgres","permalink":"/blog/tags/postgres"},{"inline":true,"label":"go","permalink":"/blog/tags/go"}],"readingTime":4.62,"hasTruncateMarker":true,"authors":[{"name":"Fiber Team","title":"Maintainers","url":"https://github.com/gofiber/fiber","imageURL":"https://github.com/gofiber.png","key":"fiber-team","page":null}],"frontMatter":{"slug":"build-a-crud-app-with-fiber","title":"Build a CRUD API with Fiber","authors":["fiber-team"],"tags":["fiber","v3","crud","gorm","postgres","go"],"description":"Build a practical CRUD API in Fiber v3 and keep the request flow understandable as it grows."},"unlisted":false,"prevItem":{"title":"Serve Static Files with Fiber v3","permalink":"/blog/static-server-with-fiber-v3"},"nextItem":{"title":"What\'s New in Fiber v3","permalink":"/blog/whats-new-in-fiber-v3"}}')}}]);