"use strict";(self.webpackChunkfiber_docs=self.webpackChunkfiber_docs||[]).push([["98601"],{89749:function(e,t,n){n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var s=n(16259),i=n(74848),r=n(84429);let a={slug:"fiber-v3-custom-context",title:"Custom Context in Practice",authors:["fiber-team"],tags:["fiber","v3","context","architecture","go"],description:"Extend context safely with NewWithCustomCtx for cleaner handler code."},o,c={authorsImageUrls:[void 0]},l=[{value:"How Teams Solved This in v2",id:"how-teams-solved-this-in-v2",level:2},{value:"How v3 Custom Context Works",id:"how-v3-custom-context-works",level:2},{value:"Why This Matters for Multi-Tenant Systems",id:"why-this-matters-for-multi-tenant-systems",level:2},{value:"What Belongs in Custom Context",id:"what-belongs-in-custom-context",level:2},{value:"Testing Custom Context",id:"testing-custom-context",level:2},{value:"Migrating from Locals to Custom Context",id:"migrating-from-locals-to-custom-context",level:2},{value:"Internal References",id:"internal-references",level:2}];function d(e){let t={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"As backend services mature, handlers start repeating the same request plumbing over and over again. Tenant resolution, actor identification, correlation values, access-scoped metadata. None of this is business logic, but all of it is required before any business logic can run."}),"\n",(0,i.jsxs)(t.p,{children:["In a typical multi-tenant API, every handler opens with five or six lines of header extraction and default-value logic. When that logic is duplicated across fifty endpoints, small inconsistencies creep in. One handler reads ",(0,i.jsx)(t.code,{children:"X-Tenant-ID"}),", another reads ",(0,i.jsx)(t.code,{children:"X-TenantID"}),", a third falls back to a query parameter. Custom context gives that plumbing a single, typed home."]}),"\n",(0,i.jsx)(t.h2,{id:"how-teams-solved-this-in-v2",children:"How Teams Solved This in v2"}),"\n",(0,i.jsxs)(t.p,{children:["In v2, the most common pattern was a combination of middleware setting ",(0,i.jsx)(t.code,{children:"c.Locals()"})," values and helper functions extracting them:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-go",children:'// v2: middleware sets locals\nfunc TenantMiddleware(c *fiber.Ctx) error {\n    tenantID := c.Get("X-Tenant-ID")\n    if tenantID == "" {\n        tenantID = "public"\n    }\n    c.Locals("tenantID", tenantID)\n    return c.Next()\n}\n\n// v2: helper function reads locals\nfunc GetTenantID(c *fiber.Ctx) string {\n    if v, ok := c.Locals("tenantID").(string); ok {\n        return v\n    }\n    return "public"\n}\n\n// v2: every handler calls the helper\napp.Get("/data", func(c *fiber.Ctx) error {\n    tenantID := GetTenantID(c)\n    // ...\n})\n'})}),"\n",(0,i.jsxs)(t.p,{children:["This worked, but it had problems. The ",(0,i.jsx)(t.code,{children:"Locals"})," key was a string, so typos were silent failures. The helper function lived in a utility package that handlers had to import. The type assertion could fail. And nothing prevented a handler from reading locals directly with a different key, bypassing the helper entirely."]}),"\n",(0,i.jsx)(t.p,{children:"Over time, teams ended up with multiple helper packages, inconsistent naming, and no compile-time guarantee that the right metadata was available."}),"\n",(0,i.jsx)(t.h2,{id:"how-v3-custom-context-works",children:"How v3 Custom Context Works"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"NewWithCustomCtx"})," lets you define a typed context struct that embeds ",(0,i.jsx)(t.code,{children:"fiber.DefaultCtx"})," and adds application-specific methods. The methods are available on every handler's context without imports, casts, or string keys:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-go",children:'type AppCtx struct {\n    fiber.DefaultCtx\n}\n\nfunc (c *AppCtx) TenantID() string {\n    return c.Get("X-Tenant-ID", "public")\n}\n\nfunc (c *AppCtx) ActorID() string {\n    return c.Get("X-Actor-ID", "anonymous")\n}\n\nfunc (c *AppCtx) RequestID() string {\n    return c.Get("X-Request-ID")\n}\n\napp := fiber.NewWithCustomCtx(func(app *fiber.App) fiber.CustomCtx {\n    return &AppCtx{DefaultCtx: *fiber.NewDefaultCtx(app)}\n})\n'})}),"\n",(0,i.jsx)(t.p,{children:"Handlers use a type assertion to access the custom methods:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-go",children:'app.Get("/whoami", func(c fiber.Ctx) error {\n    cc := c.(*AppCtx)\n    return c.JSON(fiber.Map{\n        "tenant": cc.TenantID(),\n        "actor":  cc.ActorID(),\n        "reqID":  cc.RequestID(),\n    })\n})\n'})}),"\n",(0,i.jsx)(t.p,{children:"The type assertion is the only boilerplate. Everything else \u2014 header reading, default values, naming conventions \u2014 lives in one place and is enforced by the compiler."}),"\n",(0,i.jsx)(t.h2,{id:"why-this-matters-for-multi-tenant-systems",children:"Why This Matters for Multi-Tenant Systems"}),"\n",(0,i.jsx)(t.p,{children:"In a multi-tenant API, almost every database query, cache key, and audit log entry needs a tenant identifier. If that identifier comes from a helper function that can be forgotten, you get data leaks (queries without tenant scope) or audit gaps (log entries without tenant context)."}),"\n",(0,i.jsx)(t.p,{children:"With custom context, the method is always available and always returns a consistent value. You can also add computed properties that combine multiple request values:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-go",children:'func (c *AppCtx) AuditContext() map[string]string {\n    return map[string]string{\n        "tenant":  c.TenantID(),\n        "actor":   c.ActorID(),\n        "request": c.RequestID(),\n        "ip":      c.IP(),\n    }\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"Audit logging then becomes a single call instead of four separate extractions per handler."}),"\n",(0,i.jsx)(t.h2,{id:"what-belongs-in-custom-context",children:"What Belongs in Custom Context"}),"\n",(0,i.jsx)(t.p,{children:"Custom context should be a boundary helper, not a domain layer. Good candidates:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Request metadata extraction (tenant, actor, correlation IDs)"}),"\n",(0,i.jsx)(t.li,{children:"Header convenience methods with defaults"}),"\n",(0,i.jsx)(t.li,{children:"Request-scoped computed properties (audit maps, permission flags)"}),"\n",(0,i.jsx)(t.li,{children:"Common response patterns (standard error envelopes)"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["What does ",(0,i.jsx)(t.strong,{children:"not"})," belong in custom context:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Database access or repository calls"}),"\n",(0,i.jsx)(t.li,{children:"Business logic or validation rules"}),"\n",(0,i.jsx)(t.li,{children:"Heavy computation that should live in a service layer"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Keep the context thin. If a method needs more than the request itself to do its work, it probably belongs in a service package that receives the context as a parameter."}),"\n",(0,i.jsx)(t.h2,{id:"testing-custom-context",children:"Testing Custom Context"}),"\n",(0,i.jsxs)(t.p,{children:["Since custom context methods only depend on the request, they are easy to test with ",(0,i.jsx)(t.code,{children:"app.Test()"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-go",children:'app := fiber.NewWithCustomCtx(func(app *fiber.App) fiber.CustomCtx {\n    return &AppCtx{DefaultCtx: *fiber.NewDefaultCtx(app)}\n})\n\napp.Get("/test", func(c fiber.Ctx) error {\n    cc := c.(*AppCtx)\n    return c.JSON(fiber.Map{"tenant": cc.TenantID()})\n})\n\nreq := httptest.NewRequest("GET", "/test", nil)\nreq.Header.Set("X-Tenant-ID", "acme")\n\nresp, _ := app.Test(req)\n// resp body contains {"tenant":"acme"}\n'})}),"\n",(0,i.jsx)(t.p,{children:"No mocking, no dependency injection for the context layer itself. The custom methods are pure request readers."}),"\n",(0,i.jsx)(t.h2,{id:"migrating-from-locals-to-custom-context",children:"Migrating from Locals to Custom Context"}),"\n",(0,i.jsxs)(t.p,{children:["If your v2 codebase uses ",(0,i.jsx)(t.code,{children:"Locals"})," for request metadata, the migration path is straightforward:"]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["Define an ",(0,i.jsx)(t.code,{children:"AppCtx"})," struct with methods that replace each ",(0,i.jsx)(t.code,{children:"Locals"})," key"]}),"\n",(0,i.jsxs)(t.li,{children:["Initialize the app with ",(0,i.jsx)(t.code,{children:"NewWithCustomCtx"})]}),"\n",(0,i.jsxs)(t.li,{children:["Replace ",(0,i.jsx)(t.code,{children:"GetTenantID(c)"})," calls with ",(0,i.jsx)(t.code,{children:"c.(*AppCtx).TenantID()"})]}),"\n",(0,i.jsx)(t.li,{children:"Remove the middleware that set locals (the custom method reads headers directly)"}),"\n",(0,i.jsx)(t.li,{children:"Remove the helper packages"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"The result is fewer moving parts: no middleware setting values, no helpers reading them, no string keys that can drift."}),"\n",(0,i.jsx)(t.h2,{id:"internal-references",children:"Internal References"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"/api/app",children:"App API"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"/api/ctx",children:"Ctx API"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"/whats_new",children:"What's New"})}),"\n"]})]})}function h(e={}){let{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},84429:function(e,t,n){n.d(t,{R:()=>a,x:()=>o});var s=n(96540);let i={},r=s.createContext(i);function a(e){let t=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:t},e.children)}},16259:function(e){e.exports=JSON.parse('{"permalink":"/blog/fiber-v3-custom-context","editUrl":"https://github.com/gofiber/docs/tree/master/blog/2026-02-17-fiber-v3-custom-context.md","source":"@site/blog/2026-02-17-fiber-v3-custom-context.md","title":"Custom Context in Practice","description":"Extend context safely with NewWithCustomCtx for cleaner handler code.","date":"2026-02-17T00:00:00.000Z","tags":[{"inline":true,"label":"fiber","permalink":"/blog/tags/fiber"},{"inline":true,"label":"v3","permalink":"/blog/tags/v-3"},{"inline":true,"label":"context","permalink":"/blog/tags/context"},{"inline":true,"label":"architecture","permalink":"/blog/tags/architecture"},{"inline":true,"label":"go","permalink":"/blog/tags/go"}],"readingTime":3.96,"hasTruncateMarker":true,"authors":[{"name":"Fiber Team","title":"Maintainers","url":"https://github.com/gofiber/fiber","imageURL":"https://github.com/gofiber.png","key":"fiber-team","page":null}],"frontMatter":{"slug":"fiber-v3-custom-context","title":"Custom Context in Practice","authors":["fiber-team"],"tags":["fiber","v3","context","architecture","go"],"description":"Extend context safely with NewWithCustomCtx for cleaner handler code."},"unlisted":false,"prevItem":{"title":"RFC Conformance in Practice","permalink":"/blog/fiber-v3-rfc-conformance"},"nextItem":{"title":"Binding in Practice","permalink":"/blog/fiber-v3-binding-in-practice"}}')}}]);