"use strict";(self.webpackChunkfiber_docs=self.webpackChunkfiber_docs||[]).push([["66638"],{92740:function(e,r,t){t.r(r),t.d(r,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>n,toc:()=>d});var n=t(43311),i=t(74848),a=t(84429);let s={slug:"fiber-v3-adapter-pattern",title:"Handler Compatibility in the New Router",authors:["fiber-team"],tags:["fiber","v3","router","handler","compatibility","migration","go"],description:"How Fiber's new router compatibility layer lets you use Fiber, net/http, and fasthttp handlers side by side."},l,o={authorsImageUrls:[void 0]},d=[{value:"The Migration Problem This Solves",id:"the-migration-problem-this-solves",level:2},{value:"Supported Handler Styles",id:"supported-handler-styles",level:2},{value:"How <code>next</code> Wiring Works",id:"how-next-wiring-works",level:2},{value:"RouteChain: Express-style Route Declaration",id:"routechain-express-style-route-declaration",level:2},{value:"Automatic HEAD Routes",id:"automatic-head-routes",level:2},{value:"Stricter Middleware Prefix Matching",id:"stricter-middleware-prefix-matching",level:2},{value:"A Practical Migration Pattern",id:"a-practical-migration-pattern",level:2},{value:"When to Prefer Native Fiber Immediately",id:"when-to-prefer-native-fiber-immediately",level:2},{value:"Internal References",id:"internal-references",level:2}];function c(e){let r={a:"a",code:"code",h2:"h2",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.p,{children:["One of the most underrated improvements in the v3 router is not a new method or fancy syntax. It is ",(0,i.jsx)(r.strong,{children:"handler compatibility"}),"."]}),"\n",(0,i.jsx)(r.p,{children:"In plain terms: Fiber can now accept multiple handler styles directly, and the router compatibility layer adapts them for you. That sounds small until you are migrating a real codebase with hundreds of handlers, middleware functions, and utility packages in different styles. Then it becomes the feature that decides whether migration happens this quarter or gets postponed again."}),"\n",(0,i.jsx)(r.h2,{id:"the-migration-problem-this-solves",children:"The Migration Problem This Solves"}),"\n",(0,i.jsxs)(r.p,{children:["Most teams do not start from a greenfield codebase. They have ",(0,i.jsx)(r.code,{children:"net/http"})," handlers written years ago, ",(0,i.jsx)(r.code,{children:"fasthttp"})," handlers from performance-critical paths, middleware contracts in various styles, and helper functions that mix handler signatures."]}),"\n",(0,i.jsx)(r.p,{children:"Before this compatibility model, migration usually meant one of two painful paths:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Rewrite all handler signatures upfront, even when business logic had not changed. This creates a large, risky PR that touches every endpoint."}),"\n",(0,i.jsx)(r.li,{children:"Maintain local custom adapters that wrap old handlers. These wrappers are inconsistent across modules, and nobody cleans them up after migration."}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"Both approaches increase risk and slow down migration. The v3 compatibility layer eliminates this tradeoff by accepting supported handler shapes directly in the router."}),"\n",(0,i.jsx)(r.h2,{id:"supported-handler-styles",children:"Supported Handler Styles"}),"\n",(0,i.jsx)(r.p,{children:"The router adapter understands 17 handler signatures across four families:"}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Native Fiber handlers"})," \u2014 the cleanest long-term choice:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:'app.Get("/health", func(c fiber.Ctx) error {\n    return c.SendString("ok")\n})\n'})}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsxs)(r.strong,{children:["Standard library ",(0,i.jsx)(r.code,{children:"net/http"})," handlers"]})," \u2014 for legacy code and ecosystem packages:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:'mux := http.NewServeMux()\nmux.HandleFunc("/legacy", func(w http.ResponseWriter, r *http.Request) {\n    w.WriteHeader(http.StatusOK)\n    _, _ = w.Write([]byte("legacy route"))\n})\n\napp.Get("/legacy", mux.ServeHTTP)\n'})}),"\n",(0,i.jsxs)(r.p,{children:["This is especially useful when one route still depends on old middleware or legacy packages that only expose ",(0,i.jsx)(r.code,{children:"http.Handler"})," interfaces."]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsxs)(r.strong,{children:[(0,i.jsx)(r.code,{children:"fasthttp"})," handlers"]})," \u2014 for existing performance-critical code:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:'app.Get("/fast", func(ctx *fasthttp.RequestCtx) {\n    ctx.SetStatusCode(fasthttp.StatusOK)\n    _, _ = ctx.WriteString("fast path")\n})\n'})}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsxs)(r.strong,{children:["Express-style ",(0,i.jsx)(r.code,{children:"Req"}),"/",(0,i.jsx)(r.code,{children:"Res"})," handlers"]})," \u2014 for teams migrating from Express or who prefer that mental model:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:'app.Use(func(req fiber.Req, res fiber.Res, next func() error) error {\n    res.Set("X-Trace-Source", "compat-layer")\n    return next()\n})\n\napp.Get("/hello", func(req fiber.Req, res fiber.Res) {\n    _ = res.SendString("hello")\n})\n'})}),"\n",(0,i.jsxs)(r.p,{children:["The Express-style callbacks support both two-argument (handler) and three-argument (middleware with ",(0,i.jsx)(r.code,{children:"next"}),") forms, with or without error returns. The adapter also supports ",(0,i.jsx)(r.code,{children:"next"})," callbacks that accept errors (",(0,i.jsx)(r.code,{children:"func(error)"})," or ",(0,i.jsx)(r.code,{children:"func(error) error"}),"), so middleware control flow works across all styles."]}),"\n",(0,i.jsxs)(r.h2,{id:"how-next-wiring-works",children:["How ",(0,i.jsx)(r.code,{children:"next"})," Wiring Works"]}),"\n",(0,i.jsxs)(r.p,{children:["A subtle but important detail is how ",(0,i.jsx)(r.code,{children:"next"})," is connected across handler styles. When you use optional ",(0,i.jsx)(r.code,{children:"next"})," callbacks in Express-style handlers, Fiber wires them to ",(0,i.jsx)(r.code,{children:"c.Next()"})," internally:"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["Calling ",(0,i.jsx)(r.code,{children:"next(nil)"})," (or ",(0,i.jsx)(r.code,{children:"next()"})," for the no-argument variant) continues the middleware chain"]}),"\n",(0,i.jsxs)(r.li,{children:["Passing a non-nil error to ",(0,i.jsx)(r.code,{children:"next(err)"})," short-circuits and returns that error"]}),"\n",(0,i.jsxs)(r.li,{children:["If your handler returns an ",(0,i.jsx)(r.code,{children:"error"}),", the value returned from the injected ",(0,i.jsx)(r.code,{children:"next()"})," bubbles straight back to the caller"]}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:["This means middleware behavior follows expected control flow even when handlers use different signature styles. A ",(0,i.jsx)(r.code,{children:"net/http"})," middleware and an Express-style middleware in the same chain will propagate errors consistently."]}),"\n",(0,i.jsx)(r.h2,{id:"routechain-express-style-route-declaration",children:"RouteChain: Express-style Route Declaration"}),"\n",(0,i.jsxs)(r.p,{children:["Beyond handler compatibility, the v3 router also adds ",(0,i.jsx)(r.code,{children:"RouteChain"}),", a helper inspired by ",(0,i.jsxs)(r.a,{href:"https://expressjs.com/en/api.html#app.route",children:["Express's ",(0,i.jsx)(r.code,{children:"app.route()"})]})," that lets you declare multiple HTTP methods on the same path without repeating it:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:'app.RouteChain("/api").RouteChain("/user/:id?").\n    Get(func(c fiber.Ctx) error {\n        return c.JSON(fiber.Map{"action": "get user", "id": c.Params("id")})\n    }).\n    Post(func(c fiber.Ctx) error {\n        return c.JSON(fiber.Map{"action": "create user"})\n    }).\n    Put(func(c fiber.Ctx) error {\n        return c.JSON(fiber.Map{"action": "update user", "id": c.Params("id")})\n    }).\n    Delete(func(c fiber.Ctx) error {\n        return c.JSON(fiber.Map{"action": "delete user", "id": c.Params("id")})\n    })\n'})}),"\n",(0,i.jsx)(r.p,{children:"This is particularly clean for resource-style APIs where GET, POST, PUT, and DELETE all operate on the same path."}),"\n",(0,i.jsx)(r.h2,{id:"automatic-head-routes",children:"Automatic HEAD Routes"}),"\n",(0,i.jsxs)(r.p,{children:["Fiber v3 auto-registers a ",(0,i.jsx)(r.code,{children:"HEAD"})," route for every ",(0,i.jsx)(r.code,{children:"GET"})," route. The generated handler chain matches the ",(0,i.jsx)(r.code,{children:"GET"})," chain, so status codes and headers stay in sync while the response body remains empty:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:'app.Get("/health", func(c fiber.Ctx) error {\n    c.Set("X-Service", "api")\n    return c.SendString("OK")\n})\n\n// HEAD /health automatically returns headers without body\n'})}),"\n",(0,i.jsxs)(r.p,{children:["You can still register explicit ",(0,i.jsx)(r.code,{children:"HEAD"})," handlers to override the generated ones, and you can disable this entirely with ",(0,i.jsx)(r.code,{children:"fiber.Config{DisableHeadAutoRegister: true}"})," if you prefer to manage HEAD routes yourself."]}),"\n",(0,i.jsx)(r.h2,{id:"stricter-middleware-prefix-matching",children:"Stricter Middleware Prefix Matching"}),"\n",(0,i.jsxs)(r.p,{children:["The v3 router aligns middleware registration closer to Express. Prefix matching is now stricter: partial matches must end at a slash boundary or be an exact match. This prevents ",(0,i.jsx)(r.code,{children:"/api"})," middleware from accidentally running on ",(0,i.jsx)(r.code,{children:"/apiv1"}),":"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:'// This middleware only runs for /api and /api/... paths\n// It does NOT run for /apiv1 or /api-internal\napp.Use("/api", apiMiddleware)\n'})}),"\n",(0,i.jsx)(r.p,{children:"You can also register middleware for multiple prefixes at once:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:'app.Use([]string{"/v1", "/v2"}, func(c fiber.Ctx) error {\n    return c.Next()\n})\n'})}),"\n",(0,i.jsxs)(r.p,{children:["And sub-apps can be mounted with ",(0,i.jsx)(r.code,{children:"app.Use()"})," instead of the old ",(0,i.jsx)(r.code,{children:"app.Mount()"}),":"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:'api := fiber.New()\napi.Get("/users", listUsers)\n\napp.Use("/api", api)\n'})}),"\n",(0,i.jsx)(r.h2,{id:"a-practical-migration-pattern",children:"A Practical Migration Pattern"}),"\n",(0,i.jsx)(r.p,{children:"A migration pattern that works well in real teams:"}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Keep legacy routes operational"})," using compatibility handlers. Register existing ",(0,i.jsx)(r.code,{children:"net/http"})," or ",(0,i.jsx)(r.code,{children:"fasthttp"})," handlers directly in the Fiber router. No wrappers needed."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Migrate high-traffic routes first"})," to native Fiber handlers. These benefit most from Fiber-specific APIs like binding, custom context, and hooks."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Remove compatibility paths"})," once ownership and test coverage are stable."]}),"\n"]}),"\n",(0,i.jsx)(r.mermaid,{value:'flowchart LR\n    A["Legacy net/http handlers"] --\x3e B["Register via compatibility layer"]\n    B --\x3e C["Run alongside native Fiber handlers"]\n    C --\x3e D["Migrate route by route"]\n    D --\x3e E["All native Fiber handlers"]'}),"\n",(0,i.jsxs)(r.p,{children:["The important point is that compatibility is a ",(0,i.jsx)(r.strong,{children:"transition tool"}),", not a permanent architecture target. Native Fiber handlers are the right long-term choice for hot paths, new endpoints, and code that uses Fiber-specific context APIs."]}),"\n",(0,i.jsx)(r.h2,{id:"when-to-prefer-native-fiber-immediately",children:"When to Prefer Native Fiber Immediately"}),"\n",(0,i.jsx)(r.p,{children:"Even with compatibility support, choose native Fiber handlers for:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"New endpoints (no legacy code to preserve)"}),"\n",(0,i.jsx)(r.li,{children:"Performance-sensitive paths (native handlers avoid adapter overhead)"}),"\n",(0,i.jsx)(r.li,{children:"Code that needs binding, custom context, or hooks"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"Use compatibility where it reduces migration risk, not where it increases long-term complexity."}),"\n",(0,i.jsx)(r.h2,{id:"internal-references",children:"Internal References"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["Official section: ",(0,i.jsx)(r.a,{href:"/whats_new#handler-compatibility",children:"What's New: Handler compatibility"})]}),"\n",(0,i.jsxs)(r.li,{children:["API docs: ",(0,i.jsx)(r.a,{href:"/api/app",children:"App Router Methods"})]}),"\n",(0,i.jsxs)(r.li,{children:["Middleware docs: ",(0,i.jsx)(r.a,{href:"/middleware/adaptor",children:"Adaptor Middleware"})]}),"\n"]})]})}function h(e={}){let{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},84429:function(e,r,t){t.d(r,{R:()=>s,x:()=>l});var n=t(96540);let i={},a=n.createContext(i);function s(e){let r=n.useContext(a);return n.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),n.createElement(a.Provider,{value:r},e.children)}},43311:function(e){e.exports=JSON.parse('{"permalink":"/blog/fiber-v3-adapter-pattern","editUrl":"https://github.com/gofiber/docs/tree/master/blog/2026-02-19-fiber-v3-adapter-pattern.md","source":"@site/blog/2026-02-19-fiber-v3-adapter-pattern.md","title":"Handler Compatibility in the New Router","description":"How Fiber\'s new router compatibility layer lets you use Fiber, net/http, and fasthttp handlers side by side.","date":"2026-02-19T00:00:00.000Z","tags":[{"inline":true,"label":"fiber","permalink":"/blog/tags/fiber"},{"inline":true,"label":"v3","permalink":"/blog/tags/v-3"},{"inline":true,"label":"router","permalink":"/blog/tags/router"},{"inline":true,"label":"handler","permalink":"/blog/tags/handler"},{"inline":true,"label":"compatibility","permalink":"/blog/tags/compatibility"},{"inline":true,"label":"migration","permalink":"/blog/tags/migration"},{"inline":true,"label":"go","permalink":"/blog/tags/go"}],"readingTime":5.12,"hasTruncateMarker":true,"authors":[{"name":"Fiber Team","title":"Maintainers","url":"https://github.com/gofiber/fiber","imageURL":"https://github.com/gofiber.png","key":"fiber-team","page":null}],"frontMatter":{"slug":"fiber-v3-adapter-pattern","title":"Handler Compatibility in the New Router","authors":["fiber-team"],"tags":["fiber","v3","router","handler","compatibility","migration","go"],"description":"How Fiber\'s new router compatibility layer lets you use Fiber, net/http, and fasthttp handlers side by side."},"unlisted":false,"prevItem":{"title":"Hooks Guide for Clean Lifecycles","permalink":"/blog/fiber-v3-hooks-guide"},"nextItem":{"title":"RFC Conformance in Practice","permalink":"/blog/fiber-v3-rfc-conformance"}}')}}]);