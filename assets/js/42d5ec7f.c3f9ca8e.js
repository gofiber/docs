"use strict";(self.webpackChunkfiber_docs=self.webpackChunkfiber_docs||[]).push([["33724"],{89855:function(e,t,r){r.r(t),r.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var i=r(853),s=r(74848),n=r(84429);let a={slug:"spa-delivery-with-fiber-v3",title:"Deliver a SPA with Fiber v3",authors:["fiber-team"],tags:["fiber","v3","spa","react","routing","static","go"],description:"Serve SPA assets and handle client-side routes correctly with Fiber v3 fallback patterns."},l,o={authorsImageUrls:[void 0]},c=[{value:"What Changed from v2",id:"what-changed-from-v2",level:2},{value:"The Core Idea: Two Route Behaviors, One Service",id:"the-core-idea-two-route-behaviors-one-service",level:2},{value:"How Request Resolution Works",id:"how-request-resolution-works",level:2},{value:"Coexisting with API Routes",id:"coexisting-with-api-routes",level:2},{value:"Run Locally",id:"run-locally",level:2},{value:"Smoke Tests That Catch Real Breakage",id:"smoke-tests-that-catch-real-breakage",level:2},{value:"What Usually Breaks in Teams",id:"what-usually-breaks-in-teams",level:2},{value:"Recipe and Next Step",id:"recipe-and-next-step",level:2}];function h(e){let t={a:"a",code:"code",h2:"h2",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"Most SPA delivery issues are not frontend bugs. They are server routing mismatches."}),"\n",(0,s.jsxs)(t.p,{children:["The homepage works, client-side navigation works, and then someone refreshes a deep link in production and gets a server-side ",(0,s.jsx)(t.code,{children:"404"}),". It happens all the time because backend and frontend route ownership was never made explicit."]}),"\n",(0,s.jsx)(t.p,{children:"Fiber v3 makes this easy to solve once you set the pattern correctly."}),"\n",(0,s.jsx)(t.h2,{id:"what-changed-from-v2",children:"What Changed from v2"}),"\n",(0,s.jsxs)(t.p,{children:["In v2, static file serving used the built-in ",(0,s.jsx)(t.code,{children:"app.Static()"})," method:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'// v2: built-in static method\napp.Static("/", "./web/build")\n'})}),"\n",(0,s.jsxs)(t.p,{children:["In v3, ",(0,s.jsx)(t.code,{children:"app.Static()"})," is removed. You use the static middleware instead, which gives you more control over fallback behavior, caching, and 404 handling. The ",(0,s.jsx)(t.code,{children:"Filesystem"})," middleware has also been removed \u2014 the static middleware covers both cases."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'// v3: static middleware\nimport "github.com/gofiber/fiber/v3/middleware/static"\n\napp.Get("/*", static.New("./web/build"))\n'})}),"\n",(0,s.jsx)(t.p,{children:"For SPA delivery, this change is actually an improvement because the middleware configuration gives you explicit control over how missing files are handled \u2014 which is exactly what SPA fallback routing needs."}),"\n",(0,s.jsx)(t.h2,{id:"the-core-idea-two-route-behaviors-one-service",children:"The Core Idea: Two Route Behaviors, One Service"}),"\n",(0,s.jsx)(t.p,{children:"Serving an SPA correctly means your backend must do two different things:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"serve real static assets when the file exists (CSS, JS, images)"}),"\n",(0,s.jsxs)(t.li,{children:["return ",(0,s.jsx)(t.code,{children:"index.html"})," for app routes that the client router owns"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"react-router"})," recipe demonstrates this clearly:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'app := fiber.New()\n\n// Static assets\napp.Get("/*", static.New("./web/build"))\n\n// SPA fallback \u2014 serves index.html for any route the static middleware does not match\napp.Get("*", static.New("./web/build/index.html"))\n\nlog.Fatal(app.Listen(":8080"))\n'})}),"\n",(0,s.jsxs)(t.p,{children:["If your app is mounted under a subpath (for example ",(0,s.jsx)(t.code,{children:"/web"}),"), server paths and frontend router basename must match."]}),"\n",(0,s.jsx)(t.h2,{id:"how-request-resolution-works",children:"How Request Resolution Works"}),"\n",(0,s.jsx)(t.mermaid,{value:'flowchart LR\n    A["Browser requests URL"] --\x3e B{"Is this a real asset file?"}\n    B -- yes --\x3e C["Serve static asset"]\n    B -- no --\x3e D["Serve index.html"]\n    D --\x3e E["Client router renders target page"]'}),"\n",(0,s.jsx)(t.p,{children:'This is the mental model you want every team member to share. It prevents endless "is this a frontend issue or backend issue?" loops.'}),"\n",(0,s.jsx)(t.h2,{id:"coexisting-with-api-routes",children:"Coexisting with API Routes"}),"\n",(0,s.jsx)(t.p,{children:"Most SPAs need API endpoints alongside the static frontend. The key is route ordering: register API routes before the SPA fallback so they take priority:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'app := fiber.New()\n\n// API routes \u2014 registered first, take priority\napi := app.Group("/api")\napi.Get("/users", listUsers)\napi.Post("/users", createUser)\napi.Get("/health", healthCheck)\n\n// Static assets\napp.Get("/*", static.New("./web/build"))\n\n// SPA fallback \u2014 catches everything else\napp.Get("*", static.New("./web/build/index.html"))\n'})}),"\n",(0,s.jsxs)(t.p,{children:["With this ordering, a request to ",(0,s.jsx)(t.code,{children:"/api/users"})," hits the API handler. A request to ",(0,s.jsx)(t.code,{children:"/dashboard"})," falls through to the static middleware, finds no file, and then the fallback serves ",(0,s.jsx)(t.code,{children:"index.html"})," so the client router can render the dashboard page."]}),"\n",(0,s.jsxs)(t.p,{children:["If you use v3's stricter middleware prefix matching, ",(0,s.jsx)(t.code,{children:"/api"})," routes will not accidentally match ",(0,s.jsx)(t.code,{children:"/api-docs"})," or ",(0,s.jsx)(t.code,{children:"/api-key-generator"})," paths. This prevents a common source of routing confusion in apps that have both API endpoints and pages with similar prefixes."]}),"\n",(0,s.jsx)(t.h2,{id:"run-locally",children:"Run Locally"}),"\n",(0,s.jsx)(t.p,{children:"Use the recipe workflow. Docker is usually the easiest path for consistent setup."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"git clone https://github.com/gofiber/recipes.git\ncd recipes/react-router\n\n# Option A: Docker (recommended by recipe)\ndocker build . -t react-router:latest\ndocker run -d -p 8080:8080 react-router:latest\n\n# Option B: Manual toolchain\ncd web && yarn install && yarn build\ncd ..\ngo run ./cmd/react-router/main.go\n"})}),"\n",(0,s.jsx)(t.h2,{id:"smoke-tests-that-catch-real-breakage",children:"Smoke Tests That Catch Real Breakage"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"# Root should return index.html\ncurl -i http://localhost:8080/\n\n# Known client route should also return index.html (not 404)\ncurl -i http://localhost:8080/react\n\n# Unknown route should return index.html (SPA handles 404 display)\ncurl -i http://localhost:8080/does-not-exist\n\n# API route should return JSON (if you added API routes)\ncurl -i http://localhost:8080/api/health\n"})}),"\n",(0,s.jsx)(t.p,{children:"Then do the browser check that matters most:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["open a deep route directly (e.g., ",(0,s.jsx)(t.code,{children:"http://localhost:8080/react"}),")"]}),"\n",(0,s.jsx)(t.li,{children:"refresh the page"}),"\n",(0,s.jsxs)(t.li,{children:["confirm the app still loads instead of returning server ",(0,s.jsx)(t.code,{children:"404"})]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"This is the test that catches the most real-world SPA delivery bugs. If refresh works on deep routes, your fallback is set up correctly."}),"\n",(0,s.jsx)(t.h2,{id:"what-usually-breaks-in-teams",children:"What Usually Breaks in Teams"}),"\n",(0,s.jsx)(t.p,{children:"The first issue is catch-all fallback placement. If it is too early in the chain, it can hide real static files and API routes. Always register specific routes before wildcards."}),"\n",(0,s.jsxs)(t.p,{children:["The second is basename mismatch. If the frontend router expects ",(0,s.jsx)(t.code,{children:"/web"})," and the backend serves from ",(0,s.jsx)(t.code,{children:"/"}),', behavior will look random even though both sides "work" separately. This is especially common when moving between environments with different base paths (local dev vs. staging vs. production with a reverse proxy prefix).']}),"\n",(0,s.jsxs)(t.p,{children:["The third is cache confusion. If ",(0,s.jsx)(t.code,{children:"index.html"})," is cached too aggressively, users keep loading old route manifests after deploy. The fix is to set no-cache or very short ",(0,s.jsx)(t.code,{children:"MaxAge"})," for HTML files while caching versioned assets (JS, CSS with content hashes) aggressively:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'// Don\'t cache the HTML shell\napp.Get("/", static.New("./web/build/index.html", static.Config{\n    MaxAge: 0,\n}))\n\n// Cache versioned assets long-term\napp.Get("/static/*", static.New("./web/build/static", static.Config{\n    MaxAge: 31536000, // 1 year\n}))\n'})}),"\n",(0,s.jsx)(t.h2,{id:"recipe-and-next-step",children:"Recipe and Next Step"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Primary reference: ",(0,s.jsx)(t.a,{href:"https://github.com/gofiber/recipes/tree/master/react-router",children:"gofiber/recipes/react-router"})]}),"\n",(0,s.jsxs)(t.li,{children:["Alternate reference: ",(0,s.jsx)(t.a,{href:"https://github.com/gofiber/recipes/tree/master/spa",children:"gofiber/recipes/spa"})]}),"\n",(0,s.jsxs)(t.li,{children:["Related: ",(0,s.jsx)(t.a,{href:"/blog/static-server-with-fiber-v3",children:"Serve Static Files with Fiber v3"})]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"A good next step is to make cache policy explicit per file type and document route ownership between backend and frontend in your service README. If your deployment includes a reverse proxy, test the SPA fallback through the full proxy chain, not just locally."})]})}function d(e={}){let{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},84429:function(e,t,r){r.d(t,{R:()=>a,x:()=>l});var i=r(96540);let s={},n=i.createContext(s);function a(e){let t=i.useContext(n);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(n.Provider,{value:t},e.children)}},853:function(e){e.exports=JSON.parse('{"permalink":"/blog/spa-delivery-with-fiber-v3","editUrl":"https://github.com/gofiber/docs/tree/master/blog/2026-02-14-spa-delivery-with-fiber-v3.md","source":"@site/blog/2026-02-14-spa-delivery-with-fiber-v3.md","title":"Deliver a SPA with Fiber v3","description":"Serve SPA assets and handle client-side routes correctly with Fiber v3 fallback patterns.","date":"2026-02-14T00:00:00.000Z","tags":[{"inline":true,"label":"fiber","permalink":"/blog/tags/fiber"},{"inline":true,"label":"v3","permalink":"/blog/tags/v-3"},{"inline":true,"label":"spa","permalink":"/blog/tags/spa"},{"inline":true,"label":"react","permalink":"/blog/tags/react"},{"inline":true,"label":"routing","permalink":"/blog/tags/routing"},{"inline":true,"label":"static","permalink":"/blog/tags/static"},{"inline":true,"label":"go","permalink":"/blog/tags/go"}],"readingTime":4.54,"hasTruncateMarker":true,"authors":[{"name":"Fiber Team","title":"Maintainers","url":"https://github.com/gofiber/fiber","imageURL":"https://github.com/gofiber.png","key":"fiber-team","page":null}],"frontMatter":{"slug":"spa-delivery-with-fiber-v3","title":"Deliver a SPA with Fiber v3","authors":["fiber-team"],"tags":["fiber","v3","spa","react","routing","static","go"],"description":"Serve SPA assets and handle client-side routes correctly with Fiber v3 fallback patterns."},"unlisted":false,"prevItem":{"title":"New Client Deep Dive","permalink":"/blog/fiber-v3-client-deep-dive"},"nextItem":{"title":"Serve Static Files with Fiber v3","permalink":"/blog/static-server-with-fiber-v3"}}')}}]);